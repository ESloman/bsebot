"""
This file contains our class that registers all the events we listen to and do things with
"""

import logging

from typing import Union

import discord
import discord_slash
from discord_slash import SlashCommand
from discord_slash.utils import manage_commands

from apis.giphyapi import GiphyAPI
from discordbot.betcloser import BetCloser
from discordbot.clienteventclasses import OnReadyEvent, OnReactionAdd, OnMessage, OnMemberJoin, OnDirectMessage
from discordbot.clienteventclasses import OnMemberLeave, OnReactionRemove
from discordbot.eddiegainmessageclass import EddieGainMessager
from discordbot.eddiekingtask import BSEddiesKingTask
from discordbot.embedmanager import EmbedManager
from discordbot.inactiveusertask import BSEddiesInactiveUsers
from discordbot.loancollectiontask import BSEddiesLoanCollections
from discordbot.revolutiontask import BSEddiesRevolutionTask
from discordbot.serverinfotask import ServerInfo
from discordbot.slashcommandeventclasses import BSEddiesActive, BSEddiesGift, BSEddiesLeaderboard, BSEddiesView
from discordbot.slashcommandeventclasses import BSEddiesCreateBet, BSEddiesCloseBet, BSEddiesPlaceEvent
from discordbot.slashcommandeventclasses import BSEddiesPending, BSEddiesTransactionHistory, BSEddiesNotifcationToggle
from discordbot.slashcommandeventclasses import BSEddiesLoanTake, BSEddiesLoanView, BSEddiesLoanRepay, BSEddiesAdminGive
from discordbot.slashcommandeventclasses import BSEddiesAutoGeneratedBets, BSEddiesHighScore, BSEddiesAdminSwitch
from discordbot.slashcommandeventclasses import BSEddiesKing
from discordbot.slashcommandeventclasses import BSEServerTurnOff, BSEServerTurnOn, BSEToggleGameService
from mongo.bsepoints import UserPoints, UserBets


class CommandManager(object):
    """
    Class for registering all the client events and slash commands
    Needs to be initialised with a client and a list of guild IDS

    Only the constructor needs to be called in this class for it to register everything.
    """

    def __init__(self,
                 client: discord.Client,
                 guilds: list,
                 logger: logging.Logger,
                 beta_mode: bool = False,
                 debug_mode: bool = False,
                 giphy_token: str = None):
        """
        Constructor method. This does all the work in this class and no other methods need to be called.

        We start by creating all the variables we need and some also an EmbedManager class (for creating embeds),
        and our MongoDB Collection classes for interacting with those collections in the DB.

        This is also where we create an instance of "SlashCommand". This is our main class that handles registering
        of the slash commands.

        Each "event" or "slash command" has their own "class" that handles all the actual logic for when we receive
        an event or slash command. So we create instances of these classes next.

        We have the Client Event classes all being registered and then all the Slash Command events being registered.

        After that, we have our "tasks". Tasks are COG objects that perform a task at regular intervals. We use tasks
        for a variety of different things. But essentially, each one is a class and we create an instance of each one
        here. There's no need to do anything else once we instantiate each of them.

        And finally, we call the two methods that actually register all the events and slash commands.

        :param client: discord.Client object that represents our bot
        :param guilds: list of guild IDs that we're listening on
        :param logger:  logger object for logging
        :param beta_mode: whether we're in beta mode or not
        :param debug_mode: whether we're in debug mode or not
        :param giphy_token:
        """

        self.client = client
        self.slash = SlashCommand(client, sync_commands=True)
        self.beta_mode = beta_mode
        self.guilds = guilds
        self.logger = logger
        self.giphy_token = giphy_token

        self.embeds = EmbedManager(self.logger)

        self.giphyapi = GiphyAPI(self.giphy_token)

        # mongo interaction classes
        self.user_points = UserPoints()
        self.user_bets = UserBets(guilds)

        # client event classes
        self.on_ready = OnReadyEvent(client, guilds, self.logger, self.beta_mode)
        self.on_reaction_add = OnReactionAdd(client, guilds, self.logger, self.beta_mode)
        self.on_reaction_remove = OnReactionRemove(client, guilds, self.logger, self.beta_mode)
        self.on_message = OnMessage(client, guilds, self.logger, self.beta_mode)
        self.on_member_join = OnMemberJoin(client, guilds, self.logger, self.beta_mode)
        self.on_member_leave = OnMemberLeave(client, guilds, self.logger, self.beta_mode)
        self.direct_message = OnDirectMessage(client, guilds, self.logger, self.giphyapi, self.beta_mode)

        # slash command classes
        self.bseddies_active = BSEddiesActive(client, guilds, self.logger, self.beta_mode)
        self.bseddies_create = BSEddiesCreateBet(client, guilds, self.logger, self.beta_mode)
        self.bseddies_gift = BSEddiesGift(client, guilds, self.logger, self.beta_mode)
        self.bseddies_view = BSEddiesView(client, guilds, self.logger, self.beta_mode)
        self.bseddies_leaderboard = BSEddiesLeaderboard(client, guilds, self.logger, self.beta_mode)
        self.bseddies_close = BSEddiesCloseBet(client, guilds, self.logger, self.beta_mode)
        self.bseddies_place = BSEddiesPlaceEvent(client, guilds, self.logger, self.beta_mode)
        self.bseddies_pending = BSEddiesPending(client, guilds, self.logger, self.beta_mode)
        self.bseddies_transactions = BSEddiesTransactionHistory(client, guilds, self.logger, self.beta_mode)
        self.bseddies_notifcations = BSEddiesNotifcationToggle(client, guilds, self.logger, self.beta_mode)
        self.bseddies_loan_take = BSEddiesLoanTake(client, guilds, self.logger, self.beta_mode)
        self.bseddies_loan_view = BSEddiesLoanView(client, guilds, self.logger, self.beta_mode)
        self.bseddies_loan_repay = BSEddiesLoanRepay(client, guilds, self.logger, self.beta_mode)
        self.bseddies_autogen = BSEddiesAutoGeneratedBets(client, guilds, self.logger, self.beta_mode)
        self.bseddies_admin_give = BSEddiesAdminGive(client, guilds, self.logger, self.beta_mode)
        self.bseddies_high_score = BSEddiesHighScore(client, guilds, self.logger, self.beta_mode)
        self.bseddies_admin_switch = BSEddiesAdminSwitch(client, guilds, self.logger, self.beta_mode)
        self.bseddies_king = BSEddiesKing(client, guilds, self.logger, self.beta_mode)

        # tasks
        self.bet_closer_task = BetCloser(self.client, guilds, self.logger)
        self.eddie_gain_message_task = EddieGainMessager(self.client, guilds, self.logger)
        self.eddie_king_task = BSEddiesKingTask(self.client, guilds, self.logger)
        self.loan_collections = BSEddiesLoanCollections(self.client, guilds, self.logger)
        self.inactive_users = BSEddiesInactiveUsers(self.client, guilds, self.logger)
        self.revolution_task = BSEddiesRevolutionTask(self.client, guilds, self.logger, self.giphy_token)
        self.server_info = ServerInfo(self.client, self.logger)

        # server slash commands
        self.server_on = BSEServerTurnOn(client, guilds, logger, self.server_info)
        self.server_off = BSEServerTurnOff(client, guilds, logger, self.server_info)
        self.service_toggle = BSEToggleGameService(client, guilds, logger, self.server_info)

        # call the methods that register the events we're listening for
        self._register_client_events()
        self._register_slash_commands(guilds)

    # noinspection PyProtectedMember
    def __get_cached_messages_list(self) -> list:
        """
        Method for getting a list of cached message IDs
        :return: list of cached messages
        """
        deque = self.client.cached_messages._SequenceProxy__proxied
        cached = [d.id for d in deque]
        return cached

    def _register_client_events(self) -> None:
        """
        This method registers all the 'client events'.
        Client Events are normal discord events that we can listen to.
        A full list of events can be found here: https://discordpy.readthedocs.io/en/latest/api.html

        Each event must be it's own async method with a @self.client.event decorator so that it's actually
        registered. None of these methods defined here will ever be called manually by anyone. The methods are called
        by the CLIENT object and that will pass in all the required parameters.

        Additionally, the method is called automatically from this class' constructor and shouldn't be called anywhere
        else.

        :return: None
        """

        @self.client.event
        async def on_ready():
            """
            Event that handles when we're 'ready'
            :return:
            """
            await self.on_ready.on_ready()

        @self.client.event
        async def on_member_join(member: discord.Member):
            """
            Event that's called when a new member joins the guild.
            :param member:
            :return:
            """
            self.on_member_join.on_join(member)

        @self.client.event
        async def on_member_remove(member: discord.Member):
            """
            Event that's called when a member leaves the guild.
            :param member:
            :return:
            """
            self.on_member_leave.on_leave(member)

        @self.client.event
        async def on_raw_reaction_add(payload: discord.RawReactionActionEvent):
            """
            This event catches EVERY reaction event on every message in the server.
            However, any operations we want to perform are a bit slower as we need to 'fetch' the message
            before we have all the data we have. BUT, we need to handle reactions to all messages as a user may
            react to an older message that isn't in the cache and we can't just not do anything.

            If the message is in the cache - then this event will fire and so will on_reaction_add. To prevent that,
            and to keep on_reaction_add for cached messages and be faster, we check if the message_id is already
            in the cache. If it is, then we can safely ignore it here. Otherwise we need to handle it.
            :param payload:
            :return:
            """

            cached_messages = self.__get_cached_messages_list()
            if payload.message_id in cached_messages:
                # message id is already in the cache
                return

            guild = self.client.get_guild(payload.guild_id)  # type: discord.Guild
            user = guild.get_member(payload.user_id)  # type: discord.User

            if user.bot:
                return

            channel = guild.get_channel(payload.channel_id)  # type: discord.TextChannel
            partial_message = channel.get_partial_message(payload.message_id)  # type: discord.PartialMessage
            message = await partial_message.fetch()  # type: discord.Message

            await self.on_reaction_add.handle_reaction_event(message, guild, channel, payload.emoji.name, user)

        @self.client.event
        async def on_raw_reaction_remove(payload: discord.RawReactionActionEvent):
            """
            This event catches EVERY reaction removal event on every message in the server.
            However, any operations we want to perform are a bit slower as we need to 'fetch' the message
            before we have all the data we have. BUT, we need to handle reactions to all messages as a user may
            react to an older message that isn't in the cache and we can't just not do anything.

            If the message is in the cache - then this event will fire and so will on_reaction_add. To prevent that,
            and to keep on_reaction_add for cached messages and be faster, we check if the message_id is already
            in the cache. If it is, then we can safely ignore it here. Otherwise we need to handle it.
            :param payload:
            :return:
            """

            cached_messages = self.__get_cached_messages_list()
            if payload.message_id in cached_messages:
                # message id is already in the cache
                return

            guild = self.client.get_guild(payload.guild_id)  # type: discord.Guild
            user = guild.get_member(payload.user_id)  # type: discord.User

            if user.bot:
                return

            channel = guild.get_channel(payload.channel_id)  # type: discord.TextChannel
            partial_message = channel.get_partial_message(payload.message_id)  # type: discord.PartialMessage
            message = await partial_message.fetch()  # type: discord.Message

            await self.on_reaction_remove.handle_reaction_event(message, guild, channel, payload.emoji.name, user)

        @self.client.event
        async def on_reaction_add(reaction: discord.Reaction, user: discord.User):
            """
            This event is triggered when anyone 'reacts' to a message in a guild that the bot is in - even it's own
            reactions. However, this only triggers for messages that the bot has in it's cache - reactions to older
            messages will only trigger a 'on_raw_reaction_add' event.

            Here, we simply hand it off to another class to deal with.
            :param reaction:
            :param user:
            :return:
            """
            await self.on_reaction_add.handle_reaction_event(
                reaction.message,
                reaction.message.guild,
                reaction.message.channel,
                reaction.emoji,
                user
            )

        @self.client.event
        async def on_reaction_remove(reaction: discord.Reaction, user: discord.User):
            """
            This event is triggered when anyone removes a 'reaction' to a message in a guild that the bot is in -
            even it's own eactions. However, this only triggers for messages that the bot has in it's cache -
            reactions to older messages will only trigger a 'on_raw_reaction_remove' event.

            Here, we simply hand it off to another class to deal with.
            :param reaction:
            :param user:
            :return:
            """
            await self.on_reaction_remove.handle_reaction_event(
                reaction.message,
                reaction.message.guild,
                reaction.message.channel,
                reaction.emoji,
                user
            )

        @self.client.event
        async def on_message(message: discord.Message):
            """
            This is the 'message' event. Whenever a message is sent in a guild that the bot is listening for -
            we will enact this code. Here, we simply hand it off to another class to deal with.
            :param message:
            :return:
            """

            if message.author.bot:
                return

            if message.channel.type.value == 1:
                # this means we've received a Direct message!
                # we'll have to handle this differently
                self.logger.debug(f"{message} - {message.content}")
                await self.direct_message.dm_received(message)
                return

            await self.on_message.message_received(message)

    def _register_slash_commands(self, guilds: list) -> None:
        """
        This method registers all the 'slash commands'.
        Slash Commands are commands users can use in discord.

        Each command must be it's own async method with a relevant decorator so that it's actually
        registered. None of these methods defined here will ever be called manually by anyone. The methods are called
        by the CLIENT object and that will pass in all the required parameters.

        Additionally, the method is called automatically from this class' constructor and shouldn't be called anywhere
        else.

        :param guilds: The guild IDs to register the commands to
        :return: None
        """

        @self.slash.subcommand(
            base="bseserver",
            base_description="Interact with the BSE Server",
            name="on",
            description="Turn on the server",
            guild_ids=guilds)
        async def instance_on(ctx: discord_slash.context.SlashContext) -> None:
            """
            Slash command that allows the user to turn on the AWS instance
            :param ctx:
            :return:
            """
            await ctx.defer(hidden=True)
            await self.server_on.turn_server_on(ctx)

        @self.slash.subcommand(
            base="bseserver",
            base_description="Interact with the BSE Server",
            name="off",
            description="Turn off the server",
            guild_ids=guilds)
        async def instance_off(ctx: discord_slash.context.SlashContext) -> None:
            """
            Slash command that allows the user to turn off the AWS instance
            :param ctx:
            :return:
            """
            await ctx.defer(hidden=True)
            await self.server_off.turn_server_off(ctx)

        @self.slash.subcommand(
            base="bseserver",
            base_description="Interact with the BSE Server",
            name="start",
            description="Start a particular game server",
            guild_ids=guilds,
            options=[manage_commands.create_option(
                name="game_server",
                description="The game server to start",
                option_type=3,
                required=True,
                choices=[
                    manage_commands.create_choice(
                        "valheim", "Valheim"
                    ),
                    manage_commands.create_choice(
                        "minecraft_base", "Minecraft Vanilla"
                    ),
                    manage_commands.create_choice(
                        "minecraft_hardcore", "Minecraft Hardcore"
                    )
                ]
            ), ]
        )
        async def game_server_on(ctx:discord_slash.context.SlashContext, game_server: str) -> None:
            """

            :param ctx:
            :param game_server:
            :return:
            """
            await ctx.defer(hidden=True)
            await self.service_toggle.toggle_game_service(ctx, game_server, True)

        @self.slash.subcommand(
            base="bseserver",
            base_description="Interact with the BSE Server",
            name="stop",
            description="Start a particular game server",
            guild_ids=guilds,
            options=[manage_commands.create_option(
                name="game_server",
                description="The game server to start",
                option_type=3,
                required=True,
                choices=[
                    manage_commands.create_choice(
                        "valheim", "Valheim"
                    ),
                    manage_commands.create_choice(
                        "minecraft_base", "Minecraft Vanilla"
                    ),
                    manage_commands.create_choice(
                        "minecraft_hardcore", "Minecraft Hardcore"
                    )
                ]
            ), ]
        )
        async def game_server_off(ctx: discord_slash.context.SlashContext, game_server: str) -> None:
            """

            :param ctx:
            :param game_server:
            :return:
            """
            await ctx.defer(hidden=True)
            await self.service_toggle.toggle_game_service(ctx, game_server, False)

        @self.slash.subcommand(
            base="bseddies",
            base_description="View your BSEddies, create bets and resolve bets",
            name="view",
            description="View your total BSEddies",
            guild_ids=guilds)
        async def bseddies(ctx: discord_slash.context.SlashContext) -> None:
            """
            Slash command that allows the user to see how many BSEddies they have.
            :param ctx:
            :return:
            """
            await self.bseddies_view.view(ctx)

        @self.slash.subcommand(
            base="bseddies",
            base_description="View your BSEddies, create bets and resolve bets",
            name="leaderboard",
            description="View the BSEddie leaderboard.",
            guild_ids=guilds)
        async def leaderboard(ctx: discord_slash.context.SlashContext) -> None:
            """
            Slash command that allows the user to see the BSEddies leaderboard.
            :param ctx:
            :return:
            """
            await self.bseddies_leaderboard.leaderboard(ctx)

        @self.slash.subcommand(
            base="bseddies",
            base_description="View your BSEddies, create bets and resolve bets",
            name="king",
            description="View some info about the KING",
            guild_ids=guilds)
        async def king_data(ctx: discord_slash.context.SlashContext) -> None:
            """
            Slash command that allows the user to see the BSEddies KING.
            :param ctx:
            :return:
            """
            await self.bseddies_king.king_data(ctx)

        @self.slash.subcommand(
            base="bseddies",
            base_description="View your BSEddies, create bets and resolve bets",
            name="highscores",
            description="View the BSEddie High Scores.",
            guild_ids=guilds)
        async def high_scores(ctx: discord_slash.context.SlashContext) -> None:
            """
            Slash command that allows the user to see the BSEddies high scores.
            :param ctx:
            :return:
            """
            await self.bseddies_high_score.highscore(ctx)

        @self.slash.subcommand(
            base="bseddies",
            base_description="View your BSEddies, create bets and resolve bets",
            name="active",
            description="View all the active bets in the server.",
            guild_ids=guilds)
        async def active_bets(ctx: discord_slash.context.SlashContext) -> None:
            """
            Slash commands lists all the active bets in the system.
            :param ctx:
            :return:
            """
            await self.bseddies_active.active(ctx)

        @self.slash.subcommand(
            base="bseddies",
            base_description="View your BSEddies, create bets and resolve bets",
            name="pending",
            description="View all the unresolved bets you have betted on.",
            guild_ids=guilds)
        async def pending_bets(ctx: discord_slash.context.SlashContext) -> None:
            """
            Slash commands lists all the pending bets in the system for the user.
            :param ctx:
            :return:
            """
            await self.bseddies_pending.pending(ctx)

        @self.slash.subcommand(
            base="bseddies",
            base_description="View your BSEddies, create bets and resolve bets",
            name="transactions",
            description="View your transaction history.",
            options=[
                manage_commands.create_option(
                    name="full",
                    description="Whether or not you want your _entire_ transaction history or just recent transactions",
                    option_type=3,
                    required=False,
                    choices=[
                        manage_commands.create_choice(
                            "yes", "yes"
                        )
                    ]
                ),
            ],
            guild_ids=guilds)
        async def transaction_history(ctx: discord_slash.context.SlashContext, full: Union[str, None] = None) -> None:
            """
            Slash command that allows the user to see their eddie transaction history
            :param ctx:
            :param full:
            :return:
            """
            await ctx.defer(hidden=True)
            await self.bseddies_transactions.transaction_history(ctx, full)

        @self.slash.subcommand(
            base="bseddies",
            base_description="View your BSEddies, create bets and resolve bets",
            name="notifications",
            description="Toggle whether you get daily allowance messages",
            guild_ids=guilds
        )
        async def notification_toggle(ctx: discord_slash.context.SlashContext) -> None:
            await self.bseddies_notifcations.notification_toggle(ctx)

        @self.slash.subcommand(
            base="bseddies",
            base_description="View your BSEddies, create bets and resolve bets",
            name="gift",
            description="Gift some of your eddies to a friend",
            options=[
                manage_commands.create_option(
                    name="friend",
                    description="The friend to gift the eddies to.",
                    option_type=6,
                    required=True
                ),
                manage_commands.create_option(
                    name="amount",
                    description="The amount to gift to a friend.",
                    option_type=4,
                    required=True
                )
            ],
            guild_ids=guilds)
        async def gift_eddies(ctx: discord_slash.context.SlashContext, friend: discord.User, amount: int) -> None:
            """
            A slash command that allows users to gift eddies to their friends.

            It was two main arguments:
                - FRIEND: The user in the server to gift BSEddies to
                - AMOUNT: The amount of BSEddies to gift

            :param ctx:
            :param friend:
            :param amount:
            :return:
            """
            await self.bseddies_gift.gift_eddies(ctx, friend, amount)

        @self.slash.subcommand(
            base="bseddies",
            base_description="View your BSEddies, create bets and resolve bets",
            subcommand_group="bet",
            subcommand_group_description="Create or resolve bets using BSEddies",
            name="create",
            description="Create a bet. IF providing outcome names - please provide them sequentially.",
            options=[
                manage_commands.create_option(
                    name="bet_title",
                    description="What is the bet?",
                    option_type=3,
                    required=True
                ),
                manage_commands.create_option(
                    name="outcome_one",
                    description="Outcome number 1 name",
                    option_type=3,
                    required=False
                ),
                manage_commands.create_option(
                    name="outcome_two",
                    description="Outcome number 2 name",
                    option_type=3,
                    required=False
                ),
                manage_commands.create_option(
                    name="outcome_three",
                    description="Outcome number 3 name",
                    option_type=3,
                    required=False
                ),
                manage_commands.create_option(
                    name="outcome_four",
                    description="Outcome number 4 name",
                    option_type=3,
                    required=False
                ),
                manage_commands.create_option(
                    name="outcome_five",
                    description="Outcome number 5 name",
                    option_type=3,
                    required=False
                ),
                manage_commands.create_option(
                    name="outcome_six",
                    description="Outcome number 6 name",
                    option_type=3,
                    required=False
                ),
                manage_commands.create_option(
                    name="timeout",
                    description=("How long should betting be open for? Must be DIGITS + (s|m|h|d). "
                                 "Examples: 15m, 2d, 6h, etc"),
                    option_type=3,
                    required=False
                )
            ],
            guild_ids=guilds
        )
        async def handle_bet_creation(
                ctx: discord_slash.context.SlashContext,
                bet_title: str,
                outcome_one: Union[str, None] = None,
                outcome_two: Union[str, None] = None,
                outcome_three: Union[str, None] = None,
                outcome_four: Union[str, None] = None,
                outcome_five: Union[str, None] = None,
                outcome_six: Union[str, None] = None,
                timeout: Union[str, None] = None,
        ) -> None:
            """
            This is the command for bet creation. There's quite a few optional arguments here but it's
            relatively simple.

            The only required argument is BET_TITLE:
                - BET_TITLE: The title of the bet.

            If only provided BET_TITLE, the bet should be a yes/no style question as those will be the
            default outcomes.

            The next four optional arguments are all outcome names. These should be provided in numerical order -
            one, two, three, four, five, and lastly, six. And at least two should be provided if you want custom
            outcome names.

            The final optional outcome is TIMEOUT. This is a simple string consisting of 1-4 digits + s, m, h, or d.
            This indicates how long the bet should be "open" for.

            :param ctx:
            :param bet_title:
            :param outcome_one:
            :param outcome_two:
            :param outcome_three:
            :param outcome_four:
            :param outcome_five:
            :param outcome_six:
            :param timeout:
            :return:
            """
            await ctx.defer(hidden=True)
            await self.bseddies_create.handle_bet_creation(
                ctx, bet_title,
                outcome_one, outcome_two, outcome_three, outcome_four, outcome_five, outcome_six,
                timeout
            )

        @self.slash.subcommand(
            base="bseddies",
            base_description="View your BSEddies, create bets and resolve bets",
            subcommand_group="bet",
            subcommand_group_description="Create, resolve, or place bets using BSEddies",
            name="place",
            description="Place a bet",
            options=[
                manage_commands.create_option(
                    name="bet_id",
                    description="Bet ID to place a bet on",
                    option_type=3,
                    required=True
                ),
                manage_commands.create_option(
                    name="amount",
                    description="Amount of BSEddies to bet",
                    option_type=4,
                    required=True
                ),
                manage_commands.create_option(
                    name="emoji",
                    description="Which result to bet on",
                    option_type=3,
                    required=True
                ),
            ],
            guild_ids=guilds
        )
        async def do_a_bet(ctx: discord_slash.context.SlashContext, bet_id: str, amount: int, emoji: str) -> None:
            """
            This is the command that allows users to place BSEddies.  on currently active bets.

            It has 3 main arguments:
                - BET_ID : The ID of the bet
                - AMOUNT : The amount of BSEddies to bet
                - EMOJI : The result to bet on

            Users can only bet on "active" bets. IE ones that haven't timed out or ones that have results already.
            Users can't bet on a different result to one that they've already bet on.
            Users can't bet a negative amount of BSEddies.
            Users can't bet on a result that doesn't exist for that bet.

            :param ctx:
            :param bet_id:
            :param amount:
            :param emoji:
            :return:
            """
            await self.bseddies_place.place_bet(ctx, bet_id, amount, emoji)

        @self.slash.subcommand(
            base="bseddies",
            base_description="View your BSEddies, create bets and resolve bets",
            subcommand_group="bet",
            subcommand_group_description="Create, resolve, or place bets using BSEddies",
            name="close",
            description="Close a bet by providing a result and award those SWEET EDDIES.",
            options=[
                manage_commands.create_option(
                    name="bet_id",
                    description="Bet ID to close.",
                    option_type=3,
                    required=True
                ),
                manage_commands.create_option(
                    name="emoji",
                    description="Which result WON",
                    option_type=3,
                    required=True
                ),
            ],
            guild_ids=guilds
        )
        async def close_a_bet(ctx: discord_slash.context.SlashContext, bet_id: str, emoji: str) -> None:
            """
            This is the command that closes a bet. Closing a bet requires a result emoji.
            Once a bet is "closed" - no-one can bet on it and the winners will gain their BSEddies.

            It has 2 main arguments:
                - BET_ID : The ID of the bet
                - EMOJI : The result to that won

            :param ctx:
            :param bet_id:
            :param emoji:
            :return:
            """
            await ctx.defer(hidden=True)
            await self.bseddies_close.close_bet(ctx, bet_id, emoji)

        @self.slash.subcommand(
            base="bseddies",
            base_description="View your BSEddies, create bets and resolve bets",
            subcommand_group="loan",
            subcommand_group_description="Apply for a loan, view your loan, and repay your loans",
            name="apply",
            description="Apply for a loan for the specified amount. You have one week to pay that back + interest.",
            options=[
                manage_commands.create_option(
                    name="amount",
                    description="The amount of eddies to apply for",
                    option_type=4,
                    required=True,
                ),
            ],
            guild_ids=guilds,
        )
        async def apply_for_a_loan(ctx: discord_slash.context.SlashContext, amount: int) -> None:
            """
            This is a command that allows us to apply for a loan. Simply takes the amount of eddies the user would
            like to borrow.
            :param ctx:
            :param amount:
            :return:
            """
            await self.bseddies_loan_take.loan_take(ctx, amount)

        @self.slash.subcommand(
            base="bseddies",
            base_description="View your BSEddies, create bets and resolve bets",
            subcommand_group="loan",
            subcommand_group_description="Apply for a loan, view your loan, and repay your loans",
            name="view",
            description="View your active loan",
            guild_ids=guilds,
        )
        async def loan_view(ctx: discord_slash.context.SlashContext) -> None:
            """
            This is a command that simply allows the user to view their active loan (if they have one).
            :param ctx:
            :return:
            """
            await self.bseddies_loan_view.loan_view(ctx)

        @self.slash.subcommand(
            base="bseddies",
            base_description="View your BSEddies, create bets and resolve bets",
            subcommand_group="loan",
            subcommand_group_description="Apply for a loan, view your loan, and repay your loans",
            name="repay",
            description="Repay your loan",
            guild_ids=guilds,
        )
        async def loan_repay(ctx: discord_slash.context.SlashContext) -> None:
            """
            This is a command that allows the user to repay their active loan (if they have one). Loans are repaid
            in full if the user has enough eddies.
            :param ctx:
            :return:
            """
            await self.bseddies_loan_repay.loan_repay(ctx)

        @self.slash.subcommand(
            base="bseddies",
            base_description="View your BSEddies, create bets and resolve bets",
            subcommand_group="bet",
            subcommand_group_description="Create, resolve, or place bets using BSEddies",
            name="autogenerate",
            description="Autogenerate a random selection of bets for a specified scenario",
            options=[
                manage_commands.create_option(
                    name="scenario_type",
                    description="Which scenario are we creating bets for?",
                    option_type=3,
                    required=True,
                    choices=[
                        manage_commands.create_choice("valorant", "Valorant"),
                    ]
                ),
            ],
            guild_ids=guilds
        )
        async def autogenerate_bets(ctx: discord_slash.context.SlashContext, scenario_type: str) -> None:
            """

            :param ctx:
            :param scenario_type:
            :return:
            """
            await ctx.defer(hidden=True)
            await self.bseddies_autogen.generate_bets(ctx, scenario_type)

        @self.slash.subcommand(
            base="bseddies",
            base_description="View your BSEddies, create bets and resolve bets",
            subcommand_group="admin",
            subcommand_group_description="Admin commands for the admin",
            name="give",
            description="Give a user some eddies",
            options=[
                manage_commands.create_option(
                    name="user",
                    description="The user to give eddies to",
                    option_type=6,
                    required=True,
                ),
                manage_commands.create_option(
                    name="amount",
                    description="Amount of eddies to give them",
                    option_type=4,
                    required=True,
                ),
            ],
            guild_ids=guilds
        )
        async def admin_give_user_eddies(
                ctx: discord_slash.context.SlashContext, user: discord.User, amount: int) -> None:
            """
            Slash command for an admin to give eddies for someone.
            :param ctx:
            :param user:
            :param amount:
            :return:
            """
            await self.bseddies_admin_give.admin_give(ctx, user, amount)

        @self.slash.subcommand(
            base="bseddies",
            base_description="View your BSEddies, create bets and resolve bets",
            subcommand_group="admin",
            subcommand_group_description="Admin commands for the admin",
            name="switch",
            description="Switch a user's bet on a given bet",
            options=[
                manage_commands.create_option(
                    name="user",
                    description="The user to switch result for",
                    option_type=6,
                    required=True,
                ),
                manage_commands.create_option(
                    name="bet_id",
                    description="The BET ID to switch the result on",
                    option_type=3,
                    required=True,
                ),
                manage_commands.create_option(
                    name="emoji",
                    description="The new result",
                    option_type=3,
                    required=True,
                ),
            ],
            guild_ids=guilds
        )
        async def admin_give_user_eddies(
                ctx: discord_slash.context.SlashContext, user: discord.User, bet_id: str, emoji: str) -> None:
            """
            Slash command for an admin to switch a user's bet on a given bet.
            :param ctx:
            :param user:
            :param bet_id:
            :param emoji:
            :return:
            """
            await self.bseddies_admin_switch.admin_switch(ctx, user, bet_id, emoji)
