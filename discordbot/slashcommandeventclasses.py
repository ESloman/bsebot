"""
File for Slash Command Event Classes

Each class in this file corresponds to a slash command that we've register in commandmanager.CommandManager
These classes handle most of the logic for them
"""

import copy
import datetime
import math
import os
import random
import re
from typing import Union

import asyncssh
import discord
import discord_slash
import xlsxwriter

from apis.awsapi import AWSAPI
from discordbot.betmanager import BetManager
from discordbot.bot_enums import TransactionTypes, ActivityTypes
from discordbot.clienteventclasses import BaseEvent
from discordbot.constants import BETA_USERS, CREATOR, PRIVATE_CHANNEL_IDS, BSEDDIES_KING_ROLES, AWS_GAME_SERVER_INSTANCE
from discordbot.constants import BSE_SERVER_INFO_CHANNEL, BSE_SERVER_ID
from discordbot.serverinfotask import ServerInfo
from mongo.bsedataclasses import AutoGeneratedBets
from mongo.bsegames import GameServerInfo


class BSEddies(BaseEvent):
    """
    A base BSEddies event for any shared methods across
    All slash command classes will inherit from this class
    """
    def __init__(self, client, guilds, logger, beta_mode=False):
        super().__init__(client, guilds, logger, beta_mode=beta_mode)

    async def _handle_validation(self, ctx: discord_slash.context.SlashContext, **kwargs) -> bool:
        """
        Internal method for validating slash command inputs.
        :param ctx: discord ctx to use
        :param kwargs: the additional kwargs to use in validation
        :return: True or False
        """
        if ctx.guild.id not in self.guild_ids:
            return False

        if kwargs.get("admin") and ctx.author.id != CREATOR:
            msg = f"You do not have the permissions to use this command."
            await ctx.send(content=msg, hidden=True)
            return False

        if "friend" in kwargs and (
                isinstance(kwargs["friend"], discord.User) or isinstance(kwargs["friend"], discord.Member)):
            if kwargs["friend"].bot:
                msg = f"Bots cannot be gifted eddies."
                await ctx.send(content=msg, hidden=True)
                return False

            if kwargs["friend"].id == ctx.author.id:
                msg = f"You can't gift yourself points."
                await ctx.send(content=msg, hidden=True)
                return False

        if "amount" in kwargs and isinstance(kwargs["amount"], int):
            if kwargs["amount"] < 0:
                msg = f"You can't _\"gift\"_ someone negative points."
                await ctx.send(content=msg, hidden=True)
                return False

        return True


class BSEddiesView(BSEddies):
    """
    Class for handling `/bseddies view` commands
    """
    def __init__(self, client, guilds, logger, beta_mode=False):
        super().__init__(client, guilds, logger, beta_mode=beta_mode)

    async def view(self, ctx: discord_slash.context.SlashContext):
        """
        Basic view method for handling view slash commands.

        Sends an ephemeral message to the user with their total eddies and any "pending" eddies they
        have tied up in bets.

        :param ctx:
        :return:
        """
        if not await self._handle_validation(ctx):
            return

        self._add_event_type_to_activity_history(ctx.author, ctx.guild_id, ActivityTypes.BSEDDIES_VIEW)

        ret = self.user_points.find_user(
            ctx.author.id, ctx.guild.id, projection={"points": True, "high_score": True})

        pending = self.user_bets.get_user_pending_points(ctx.author.id, ctx.guild.id)
        msg = (f"You have **{ret['points']}** :money_with_wings:`BSEDDIES`:money_with_wings:!"
               f"\nAdditionally, you have `{pending}` points on 'pending bets'.\n\n"
               f"The _absolute highest_ amount of eddies you've ever had was `{ret.get('high_score', 0)}`!.")
        await ctx.send(content=msg, hidden=True)


class BSEddiesLeaderboard(BSEddies):
    """
    Class for handling `/bseddies leaderboard` commands
    """
    def __init__(self, client, guilds, logger, beta_mode=False):
        super().__init__(client, guilds, logger, beta_mode=beta_mode)

    async def leaderboard(self, ctx):
        """
        Basic method for sending the leaderboard to the channel that it was requested in.
        :param ctx:
        :return:
        """
        if not await self._handle_validation(ctx):
            return

        self._add_event_type_to_activity_history(ctx.author, ctx.guild_id, ActivityTypes.BSEDDIES_LEADERBOARD)

        embed = self.embed_manager.get_leaderboard_embed(ctx.guild, 5)
        message = await ctx.channel.send(content=embed)
        await message.add_reaction(u"▶️")


class BSEddiesHighScore(BSEddies):
    """
    Class for handling `/bseddies highscore` commands
    """
    def __init__(self, client, guilds, logger, beta_mode=False):
        super().__init__(client, guilds, logger, beta_mode=beta_mode)

    async def highscore(self, ctx):
        """
        Basic method for sending the high score board to the channel that it was requested in.
        :param ctx:
        :return:
        """
        if not await self._handle_validation(ctx):
            return

        self._add_event_type_to_activity_history(ctx.author, ctx.guild_id, ActivityTypes.BSEDDIES_HIGHSCORES)

        embed = self.embed_manager.get_highscore_embed(ctx.guild, 5)
        message = await ctx.channel.send(content=embed)
        await message.add_reaction(u"▶️")


class BSEddiesActive(BSEddies):
    """
    Class for handling `/bseddies active` commands
    """
    def __init__(self, client, guilds, logger, beta_mode=False):
        super().__init__(client, guilds, logger, beta_mode=beta_mode)

    async def active(self, ctx: discord_slash.context.SlashContext) -> None:
        """
        Simple method for listing all the active bets in the system.

        This will actually show all bets that haven't been closed yet - not purely the active ones.

        We also make an effort to hide "private" bets that were created in private channels if the channel this
        command is being sent in isn't said private channel.

        :param ctx: the command context
        :return: None
        """
        if not await self._handle_validation(ctx):
            return

        self._add_event_type_to_activity_history(ctx.author, ctx.guild_id, ActivityTypes.BSEDDIES_ACTIVE)

        bets = self.user_bets.get_all_pending_bets(ctx.guild.id)

        message = "Here are all the active bets:\n"

        for bet in bets:
            if 'channel_id' not in bet or 'message_id' not in bet:
                continue

            if bet.get("private"):
                if bet["channel_id"] != ctx.channel_id:
                    continue

            link = f"https://discordapp.com/channels/{ctx.guild.id}/{bet['channel_id']}/{bet['message_id']}"

            add_text = "OPEN FOR NEW BETS" if bet.get("active") else "CLOSED - AWAITING RESULT"

            pt = f"**{bets.index(bet) + 1})** [{bet['bet_id']} - `{add_text}`] _{bet['title']}_\n{link}\n\n"
            message += pt

            if (len(message) + 400) > 2000 and bet != bets[-1]:
                await ctx.send(content=message)
                message = ""

        if len(bets) == 0:
            message = "There are no active bets :("

        await ctx.send(content=message)


class BSEddiesPending(BSEddies):
    """
    Class for handling `/bseddies pending` commands
    """
    def __init__(self, client, guilds, logger, beta_mode=False):
        super().__init__(client, guilds, logger, beta_mode=beta_mode)

    async def pending(self, ctx: discord_slash.context.SlashContext) -> None:
        """
        Simple method for listing all the pending bets for the user that executed this command

        A 'pending' bet is a bet that hasn't been closed or resolved the the user has invested eddies in to

        This will send an ephemeral message to the user with all their pending bets.

        :param ctx: slash command context
        :return: None
        """
        if not await self._handle_validation(ctx):
            return

        self._add_event_type_to_activity_history(ctx.author, ctx.guild_id, ActivityTypes.BSEDDIES_PENDING)

        bets = self.user_bets.get_all_pending_bets_for_user(ctx.author.id, ctx.guild.id)

        message = "Here are all your pending bets:\n"

        for bet in bets:
            if 'channel_id' not in bet or 'message_id' not in bet:
                continue

            link = f"https://discordapp.com/channels/{ctx.guild.id}/{bet['channel_id']}/{bet['message_id']}"

            add_text = "OPEN FOR NEW BETS" if bet.get("active") else "CLOSED - AWAITING RESULT"

            pt = (f"**{bets.index(bet) + 1})** [{bet['bet_id']} - `{add_text}`] _{bet['title']}_"
                  f"\nOutcome: {bet['betters'][str(ctx.author.id)]['emoji']}\n"
                  f"Points: **{bet['betters'][str(ctx.author.id)]['points']}**\n{link}\n\n")
            message += pt

            if (len(message) + 400) > 2000 and bet != bets[-1]:
                await ctx.send(content=message, hidden=True)
                message = ""

        if len(bets) == 0:
            message = "You have no pending bets :("

        await ctx.send(content=message, hidden=True)


class BSEddiesGift(BSEddies):
    """
    Class for handling `/bseddies gift` command
    """
    def __init__(self, client, guilds, logger, beta_mode=False):
        super().__init__(client, guilds, logger, beta_mode=beta_mode)

    async def gift_eddies(self, ctx: discord_slash.context.SlashContext,
                          friend: discord.User,
                          amount: int) -> None:
        """
        Function for handling a 'gift eddies' event.

        We make sure that the user initiating the command has enough BSEddies to give to a friend
        and then we simply increment their friend's BSEddies and decrement theirs.

        :param ctx: slash command context
        :param friend: discord.User for the friend to give eddies to
        :param amount: the amount of eddies to give
        :return: None
        """
        if not await self._handle_validation(ctx, friend=friend, amount=amount):
            return

        self._add_event_type_to_activity_history(
            ctx.author, ctx.guild_id, ActivityTypes.BSEDDIES_GIFT,
            friend_id=friend.id, amount=amount
        )

        points = self.user_points.get_user_points(ctx.author.id, ctx.guild.id)
        if points < amount:
            msg = f"You have insufficient points to perform that action."
            await ctx.send(content=msg, hidden=True)
            return

        if not friend.dm_channel:
            await friend.create_dm()
        try:
            msg = f"**{ctx.author.name}** just gifted you `{amount}` eddies!!"
            await friend.send(content=msg)
        except discord.errors.Forbidden:
            pass

        self.user_points.decrement_points(ctx.author.id, ctx.guild.id, amount)
        self.user_points.increment_points(friend.id, ctx.guild.id, amount)

        # add to transaction history
        self.user_points.append_to_transaction_history(
            ctx.author.id,
            ctx.guild.id,
            {
                "type": TransactionTypes.GIFT_GIVE,
                "amount": amount * -1,
                "timestamp": datetime.datetime.now(),
                "user_id": friend.id,
            }
        )

        self.user_points.append_to_transaction_history(
            friend.id,
            ctx.guild.id,
            {
                "type": TransactionTypes.GIFT_RECEIVE,
                "amount": amount,
                "timestamp": datetime.datetime.now(),
                "user_id": ctx.author.id,
            }
        )

        await ctx.send(content=f"Eddies transferred to `{friend.name}`!", hidden=True)


class BSEddiesCloseBet(BSEddies):
    """
    Class for handling `/bseddies bet close` commands
    """
    def __init__(self, client, guilds, logger, beta_mode=False):
        super().__init__(client, guilds, logger, beta_mode=beta_mode)
        self.bet_manager = BetManager(logger)

    async def close_bet(
            self,
            ctx: discord_slash.context.SlashContext,
            bet_id: str,
            emoji: str,) -> None:
        """
        This is the method for handling when we close a bet.

        We validate that the user initiating the command is the user who created the bet and that
        the bet is still open in the first place. We also make sure that the result the user
        provided us is actually a valid result for the bet.

        If that's all okay - we close the bet and dish out the BSEddies to the winners.
        We also inform the winners/losers what the result was and how many BSEddies they won (if any).

        :param ctx: slash command context
        :param bet_id: str - the BET ID
        :param emoji: str - the winning outcome emoji
        :return: None
        """

        if not await self._handle_validation(ctx):
            return

        self._add_event_type_to_activity_history(
            ctx.author, ctx.guild_id, ActivityTypes.BSEDDIES_BET_CLOSE,
            bet_id=bet_id, emoji=emoji
        )

        guild = ctx.guild  # type: discord.Guild
        bet = self.user_bets.get_bet_from_id(guild.id, bet_id)
        author = ctx.author

        if not bet:
            msg = f"This bet doesn't exist."
            await ctx.send(content=msg, hidden=True)
            return

        if not bet["active"] and bet["result"] is not None:
            msg = f"You cannot close a bet that is already closed."
            await ctx.send(content=msg, hidden=True)
            return

        if bet["user"] != author.id:
            msg = f"You cannot close a bet that isn't yours."
            await ctx.send(content=msg, hidden=True)
            return

        emoji = emoji.strip()

        if emoji not in bet["option_dict"]:
            msg = f"{emoji} isn't a valid outcome so the bet can't be closed."
            await ctx.send(content=msg, hidden=True)
            return

        # the logic in this if statement only applies if the user "won" their own bet and they were the only better
        # they just get refunded the eddies that put in
        if bet_dict := bet["betters"].get(str(author.id), None):
            if len(bet["betters"]) == 1 and bet_dict["emoji"] == emoji:

                self.logger.info(f"{ctx.author.id} just won a bet ({bet_id}) where they were the only better...")
                self.user_bets.close_a_bet(bet["_id"], emoji)
                self.user_points.increment_points(author.id, guild.id, bet_dict["points"])
                self.user_points.append_to_transaction_history(
                    ctx.author.id,
                    guild.id,
                    {
                        "type": TransactionTypes.BET_REFUND,
                        "amount": bet_dict["points"],
                        "timestamp": datetime.datetime.now(),
                        "bet_id": bet_id,
                        "comment": "User won their own bet when no-one else entered."
                    }
                )
                if not author.dm_channel:
                    await author.create_dm()
                try:
                    msg = (f"Looks like you were the only person to bet on your bet and you _happened_ to win it. "
                           f"As such, you have won **nothing**. However, you have been refunded the eddies that you "
                           f"originally bet.")
                    await author.send(content=msg)
                except discord.errors.Forbidden:
                    pass

                desc = (f"**{bet['title']}**\n\nThere were no winners on this bet. {author.mention} just _happened_ "
                        f"to win a bet they created and they were the only entry. They were refunded the amount of "
                        f"eddies that they originally bet.")
                # update the message to reflect that it's closed
                channel = guild.get_channel(bet["channel_id"])
                message = channel.get_partial_message(bet["message_id"])
                await message.edit(content=desc, embed=None)
                return

        ret_dict = self.bet_manager.close_a_bet(bet_id, guild.id, emoji)

        desc = f"**{bet['title']}**\n{emoji} - **{ret_dict['outcome_name']['val']}** won!\n\n"

        for better in ret_dict["winners"]:
            desc += f"\n- {guild.get_member(int(better)).name} won `{ret_dict['winners'][better]}` eddies!"

        author = guild.get_member(ctx.author.id)

        # message the losers to tell them the bad news
        for loser in ret_dict["losers"]:
            mem = guild.get_member(int(loser))
            if not mem.dm_channel:
                await mem.create_dm()
            try:
                points_bet = ret_dict["losers"][loser]
                msg = (f"**{author.name}** just closed bet "
                       f"`[{bet_id}] - {bet['title']}` and the result was {emoji} "
                       f"(`{ret_dict['outcome_name']['val']})`.\n"
                       f"As this wasn't what you voted for - you have lost. You bet **{points_bet}** eddies.")
                await mem.send(content=msg)
            except discord.errors.Forbidden:
                pass

        # message the winners to tell them the good news
        for winner in ret_dict["winners"]:
            mem = guild.get_member(int(winner))
            if not mem.dm_channel:
                await mem.create_dm()
            try:
                msg = (f"**{author.name}** just closed bet "
                       f"`[{bet_id}] - {bet['title']}` and the result was {emoji} "
                       f"(`{ret_dict['outcome_name']['val']})`.\n"
                       f"**This means you won!!** "
                       f"You have won `{ret_dict['winners'][winner]}` BSEDDIES!!")
                await mem.send(content=msg)
            except discord.errors.Forbidden:
                pass

        # update the message to reflect that it's closed
        channel = guild.get_channel(bet["channel_id"])
        message = channel.get_partial_message(bet["message_id"])
        await message.edit(content=desc, embed=None)


class BSEddiesCreateBet(BSEddies):
    """
    Class for handling `/bseddies bet create` command
    """
    def __init__(self, client, guilds, logger, beta_mode=False):
        super().__init__(client, guilds, logger, beta_mode=beta_mode)
        self.default_two_options = {"1️⃣": {"val": "succeed"}, "2️⃣": {"val": "fail"}}
        self.multiple_options_emojis = ["1️⃣", "2️⃣", "3️⃣", "4️⃣", "5️⃣", "6️⃣"]

    async def handle_bet_creation(
            self,
            ctx: discord_slash.context.SlashContext,
            bet_title: str,
            option_one_name: Union[str, None] = None,
            option_two_name: Union[str, None] = None,
            option_three_name: Union[str, None] = None,
            option_four_name: Union[str, None] = None,
            option_five_name: Union[str, None] = None,
            option_six_name: Union[str, None] = None,
            timeout_str: Union[str, None] = None,
            autogenerated: bool = False,
    ) -> None:
        """
        The method that handles bet creation.

        We work out which outcome names we're gonna need - either custom or defaults.
        We make sure the user provided the right timeout or outcomes names (if at all).
        We then set the timeout for the bet.
        And we also work out which outcome emojis to use based of of the number of provided outcomes.

        Then we create the bet and send a message to channel the bet was created in.

        :param ctx:
        :param bet_title:
        :param option_one_name:
        :param option_two_name:
        :param option_three_name:
        :param option_four_name:
        :param option_six_name:
        :param option_five_name:
        :param timeout_str:
        :param autogenerated:
        :return:
        """
        if not await self._handle_validation(ctx):
            return

        self._add_event_type_to_activity_history(
            ctx.author, ctx.guild_id, ActivityTypes.BSEDDIES_BET_CREATE,
            bet_title=bet_title, option_one_name=option_one_name, option_two_name=option_two_name,
            option_three_name=option_three_name, option_four_name=option_four_name, option_five_name=option_five_name,
            option_six_name=option_six_name, autogenerated=autogenerated, timeout_str=timeout_str
        )

        user = self.user_points.find_user(ctx.author.id, ctx.guild.id, projection={"king": True, "points": True})
        points = user["points"]
        max_bets = (math.floor(points / 100.0) * 100) / 50
        current_bets = self.user_bets.query(
            {"guild_id": ctx.guild.id,
             "user": ctx.author.id,
             "result": None
             },
            projection={"_id": True}
        )

        current_bets = len(current_bets)

        if max_bets == 0:
            max_bets = 2

        if ctx.author.id in BETA_USERS:
            max_bets += 2

        if ctx.author.id == CREATOR:
            max_bets += 10

        if user.get("king", False):
            max_bets += 2

        if autogenerated:
            # basically just brute force our way through if we're using auto-generated bets
            max_bets += 100

        if current_bets and current_bets > max_bets:
            msg = (f"The maximum number of open bets allowed is determined by your BSEddie total. The more you have,"
                   f" the more open bets you're allowed to maintain. It looks like you already have the maximum "
                   f"number of open bets. You'll have to wait until they're closed or you have more BSEddies.")
            await ctx.send(content=msg, hidden=True)
            return

        if (option_one_name and not option_two_name) or (not option_one_name and option_two_name):
            msg = (f"If you're providing custom outcome names - you must provide at least two outcomes.\n"
                   f"Additionally, you must provide the outcomes sequentially "
                   f"(ie, outcome_one, then outcome_two, and then outcome_three, and then outcome_four.)")
            await ctx.send(content=msg, hidden=True)
            return

        if not option_one_name and not option_two_name:
            option_dict = copy.deepcopy(self.default_two_options)
        elif (option_one_name and option_two_name) and not option_three_name:
            option_dict = copy.deepcopy(self.default_two_options)
            keys = list(option_dict.keys())
            option_dict[keys[0]]["val"] = option_one_name
            option_dict[keys[1]]["val"] = option_two_name
        elif option_one_name and option_two_name and option_three_name:
            option_dict = {self.multiple_options_emojis[0]: {"val": option_one_name},
                           self.multiple_options_emojis[1]: {"val": option_two_name},
                           self.multiple_options_emojis[2]: {"val": option_three_name}}
            if option_four_name:
                option_dict[self.multiple_options_emojis[3]] = {"val": option_four_name}
            if option_five_name:
                option_dict[self.multiple_options_emojis[4]] = {"val": option_five_name}
            if option_six_name:
                option_dict[self.multiple_options_emojis[5]] = {"val": option_six_name}
        else:
            msg = (f"If you're providing custom outcome names - you must provide at least two outcomes.\n"
                   f"Additionally, you must provide the outcomes sequentially "
                   f"(ie, outcome_one, then outcome_two, and then outcome_three, and then outcome_four.)")
            await ctx.send(content=msg, hidden=True)
            return

        if timeout_str is None:
            timeout = datetime.datetime.now() + datetime.timedelta(minutes=10)
        else:
            timeout_str = timeout_str.strip()
            match = re.match(r"\d{1,5}(s|m|h|d)", timeout_str)
            if not match:
                msg = ("Your timeout string was incorrectly formatted. Needs to be 1 - 5 digits "
                       "and then either a s, m, h, or d "
                       "to signify seconds, minutes, hours, or days respectively.")
                await ctx.send(content=msg, hidden=True)
                return
            g = match.group()
            if "s" in g:
                dt_key = {"seconds": int(g.replace("s", ""))}
            elif "m" in g:
                dt_key = {"minutes": int(g.replace("m", ""))}
            elif "h" in g:
                dt_key = {"hours": int(g.replace("h", ""))}
            elif "d" in g:
                dt_key = {"days": int(g.replace("d", ""))}
            else:
                dt_key = {}
            timeout = datetime.datetime.now() + datetime.timedelta(**dt_key)

        private = ctx.channel_id in PRIVATE_CHANNEL_IDS

        bet = self.user_bets.create_new_bet(
            ctx.guild.id,
            ctx.author.id,
            bet_title,
            options=list(option_dict.keys()),
            option_dict=option_dict,
            timeout=timeout,
            private=private
        )

        embed = self.embed_manager.get_bet_embed(ctx.guild, bet["bet_id"], bet)

        member = ctx.guild.get_member(ctx.author.id)
        # embed.set_author(name=member.name)

        content = f"Bet created by {member.mention}"

        # await ctx.send(content=f"Bet created: {bet_title}", hidden=True)
        message = await ctx.channel.send(content=content, embed=embed)

        self.user_bets.update(
            {"_id": bet["_id"]},
            {"$set": {"message_id": message.id, "channel_id": message.channel.id}}
        )
        for emoji in option_dict:
            await message.add_reaction(emoji)


class BSEddiesPlaceEvent(BSEddies):
    """
    Class for handling `/bseddies bet place` commands
    """
    def __init__(self, client, guilds, logger, beta_mode=False):
        super().__init__(client, guilds, logger, beta_mode=beta_mode)

    async def place_bet(
            self,
            ctx: discord_slash.context.SlashContext,
            bet_id: str,
            amount: int,
            emoji: str,
    ) -> Union[None, bool]:
        """
        Main method for placing a bet.

        Validates that a bet exists, is active and that the user has the right amount of BSEddies.
        It also checks that the bet being placed is either new, or the same as the existing bet the user
        has for this bet.

        :param ctx:
        :param bet_id:
        :param amount:
        :param emoji:
        :return: None or a bool
        """
        if not await self._handle_validation(ctx):
            return

        self._add_event_type_to_activity_history(
            ctx.author, ctx.guild_id, ActivityTypes.BSEDDIES_BET_PLACE,
            bet_id=bet_id, amount=amount, emoji=emoji
        )

        guild = ctx.guild  # type: discord.Guild
        bet = self.user_bets.get_bet_from_id(guild.id, bet_id)

        if not bet:
            msg = f"This bet doesn't exist."
            await ctx.send(content=msg, hidden=True)
            return

        if not bet["active"]:
            msg = f"Your reaction on **Bet {bet_id}** failed as the bet is closed for new bets."
            await ctx.send(content=msg, hidden=True)
            return

        emoji = emoji.strip()

        if emoji not in bet["option_dict"]:
            msg = f"Your reaction on **Bet {bet_id}** failed as that reaction isn't a valid outcome."
            await ctx.send(content=msg, hidden=True)
            return

        if amount <= 0:
            msg = f"Cannot bet negative eddies or 0 eddies."
            await ctx.send(content=msg, hidden=True)
            return

        success = self.user_bets.add_better_to_bet(bet_id, guild.id, ctx.author.id, emoji, amount)

        if not success["success"]:
            msg = f"Your reaction on **Bet {bet_id}** failed cos __{success['reason']}__?"
            await ctx.send(content=msg, hidden=True)
            return False

        bet = self.user_bets.get_bet_from_id(guild.id, bet_id)
        channel = guild.get_channel(bet["channel_id"])
        message = channel.get_partial_message(bet["message_id"])
        embed = self.embed_manager.get_bet_embed(guild, bet_id, bet)
        self.user_points.append_to_transaction_history(
            ctx.author.id,
            guild.id,
            {
                "type": TransactionTypes.BET_PLACE,
                "amount": amount * -1,
                "timestamp": datetime.datetime.now(),
                "bet_id": bet_id,
                "comment": "Bet placed through slash command",
            }
        )
        await message.edit(embed=embed)


class BSEddiesTransactionHistory(BSEddies):
    """
    Class for handling `/bseddies transactions` command
    """
    def __init__(self, client, guilds, logger, beta_mode=False):
        super().__init__(client, guilds, logger, beta_mode=beta_mode)

    @staticmethod
    async def _handle_recent_trans(ctx: discord_slash.context.SlashContext, transaction_history: list) -> None:
        """
        This handles our 'recent transaction history' command. We take the last ten items in the transaction history and
        build a nice formatted ephemeral message with it and send it to the user.
        :param ctx:
        :param transaction_history:
        :return:
        """
        recent_history = transaction_history[-10:]

        message = "This is your recent transaction history.\n"

        for item in recent_history:
            message += (
                f"\n"
                f"**Timestamp**: {item['timestamp'].strftime('%d %b %y %H:%M:%S')}\n"
                f"**Transaction Type**: {TransactionTypes(item['type']).name}\n"
                f"**Change amount**: {item['amount']}\n"
                f"**Running eddies total**: {item['points']}\n"
                f"**Comment**: {item.get('comment', 'No comment')}\n"
            )

            if b_id := item.get("bet_id"):
                message += f"**Bet ID**: {b_id}\n"

            if l_id := item.get("loan_id"):
                message += f"**Loan ID**: {l_id}\n"

            if u_id := item.get("user_id"):
                message += f"**User ID**: {u_id}\n"

        await ctx.send(content=message, hidden=True)

    @staticmethod
    async def _handle_full_trans(ctx: discord_slash.context.SlashContext, transaction_history: list) -> None:
        """
        Method for handling out "full transaction history" command

        This mostly just builds an XLSX file that we can send to the user. We use the XLSXWRITER library to do the
        heavy lifting here.

        Once we've created the file, we send it to the user in a DM and send an ephemeral message to let the user know.
        Ephemeral messages don't support file attachments yet.
        :param ctx:
        :param transaction_history:
        :return:
        """
        path = os.path.join(os.path.expanduser("~"), "trans_files")
        f_name = f"full_trans_{ctx.author.id}.xlsx"

        if not os.path.exists(path):
            os.makedirs(path)

        full_name = os.path.join(path, f_name)

        workbook = xlsxwriter.Workbook(full_name)
        worksheet = workbook.add_worksheet("Transaction History")

        cols = ["Item", "Type", "Timestamp", "Change amount", "Eddies", "Bet ID", "Loan ID", "User ID", "Comment"]
        worksheet.write_row(0, 0, cols, workbook.add_format({"bold": True}))

        row = 1
        for item in transaction_history:
            worksheet.write_row(
                row, 0,
                [row, TransactionTypes(item['type']).name, item['timestamp'].strftime('%d %b %y %H:%M:%S'),
                 item["amount"], item["points"], item.get("bet_id", "N/A"), item.get("loan_id", "N/A"),
                 item.get("user_id", "N/A"), item.get("comment", "No comment")]
            )
            row += 1

        center_format = workbook.add_format()
        center_format.set_align('center')
        center_format.set_align('vcenter')

        worksheet.set_column("A:A", cell_format=center_format)
        worksheet.set_column("B:B", width=18)
        worksheet.set_column("C:D", width=20)
        worksheet.set_column("I:I", width=50)

        workbook.close()

        try:
            await ctx.author.send(content="Here's your full transaction history:", file=discord.File(full_name, f_name))
        except discord.Forbidden:
            # user doesn't allow DMs
            pass

        await ctx.send(content="I've sent you a DM with your full history.", hidden=True)

    async def transaction_history(self, ctx: discord_slash.context.SlashContext, full: Union[str, None]) -> None:
        """
        Gets the user history and takes the last 10 entries and then displays that list to the user
        :param ctx:
        :param full:
        :return:
        """
        if not await self._handle_validation(ctx):
            return

        self._add_event_type_to_activity_history(
            ctx.author, ctx.guild_id, ActivityTypes.BSEDDIES_TRANSACTIONS, full=full
        )

        user = self.user_points.find_user(ctx.author.id, ctx.guild.id)
        transaction_history = user["transaction_history"]

        amount = 0
        for item in transaction_history:
            if transaction_history.index(item) == 0:
                item["points"] = item["amount"]
                amount = item["amount"]
                continue
            amount += item["amount"]
            item["points"] = amount

        if full is None:
            await self._handle_recent_trans(ctx, transaction_history)
        else:
            await self._handle_full_trans(ctx, transaction_history)


class BSEddiesNotifcationToggle(BSEddies):
    """
    Class for handling `/bseddies notifcations` command
    """
    def __init__(self, client, guilds, logger, beta_mode=False):
        super().__init__(client, guilds, logger, beta_mode=beta_mode)

    async def notification_toggle(self, ctx: discord_slash.context.SlashContext) -> None:
        """
        Function for allowing the user to toggle whether they get daily salary notifications.
        :param ctx:
        :return:
        """
        if not await self._handle_validation(ctx):
            return

        self._add_event_type_to_activity_history(ctx.author, ctx.guild_id, ActivityTypes.BSEDDIES_NOTIFICATION_TOGGLE)

        user_id = ctx.author.id
        guild_id = ctx.guild.id

        user = self.user_points.find_user(user_id, guild_id)

        notification_setting = user.get("daily_eddies", False)

        notification_setting = not notification_setting

        self.user_points.set_daily_eddies_toggle(user_id, guild_id, notification_setting)

        message = f"Your daily salary notifications have now been turned **{'ON' if notification_setting else 'OFF'}**."

        await ctx.send(content=message, hidden=True)


class BSEddiesLoanTake(BSEddies):
    """
    Class for handling `/bseddies loan take` command
    """
    def __init__(self, client, guilds, logger, beta_mode=False):
        super().__init__(client, guilds, logger, beta_mode=beta_mode)

    async def loan_take(self, ctx: discord_slash.context.SlashContext, amount: int) -> None:
        """
        Method for handling the creation of a loan.

        To create a loan we must check the following conditions:
            - the user has less than 10 points
            - the user doesn't have negative points
            - the user isn't king
            - the user doesn't have an active loan
            - the user isn't trying to borrow more than 25 eddies

        If any of those conditions fail - we let the user know. Otherwise, we create the loan for the user and tell
        them how much they now owe.

        :param ctx:
        :param amount:
        :return:
        """
        if not await self._handle_validation(ctx):
            return

        self._add_event_type_to_activity_history(
            ctx.author, ctx.guild_id, ActivityTypes.BSEDDIES_LOAN_TAKE, amount=amount
        )

        user_id = ctx.author.id
        guild_id = ctx.guild.id

        now = datetime.datetime.now()

        user = self.user_points.find_user(user_id, guild_id)
        points = user["points"]

        active_loan = self.user_loans.get_active_loan_for_user(user_id, guild_id)

        if active_loan is not None:
            # user already has a loan
            message = f"You already have an active loan. Please pay back that loan before you take out a new one."
            await ctx.send(content=message, hidden=True)
            return

        if points >= 10:
            # too many points
            message = f"You have too many eddies to take a loan."
            await ctx.send(content=message, hidden=True)
            return

        if points < 0:
            # points below 0
            message = f"You can't take out a loan when you have negative eddies."
            await ctx.send(content=message, hidden=True)
            return

        if user.get("king"):
            # the KING can't take out a loan
            message = f"KINGs cannot take out loans :crown:"
            await ctx.send(content=message, hidden=True)

        if amount > 25:
            # too many monies
            message = f"You cannot take out a loan for `{amount}` - currently the maximum loan value is **50**."
            await ctx.send(content=message, hidden=True)
            return

        new_loan = self.user_loans.create_new_loan(user_id, guild_id, amount, now)
        self.user_points.increment_points(user_id, guild_id, amount)

        self.user_points.append_to_transaction_history(
            user_id, guild_id,
            {
                "type": TransactionTypes.LOAN_TAKE,
                "amount": amount,
                "timestamp": now,
                "loan_id": new_loan["loan_id"],
                "comment": "New loan taken out",
            }
        )

        self.user_points.append_to_activity_history(
            user_id, guild_id,
            {
                "type": ActivityTypes.LOAN_TAKE,
                "loan_id": new_loan["loan_id"],
                "timestamp": now,
                "comment": f"New loan taken out for {amount}"
            }
        )

        message = (f"Congratulations! Your loan application was successful. I have deposited `{amount}` eddies into "
                   f"your account. You have **FOUR DAYS** to pay back `{new_loan['amount_due']}`. If you fail to do so,"
                   f" I will take `{new_loan['amount_due'] * 2}` out of your account - even if that means you will "
                   f"have a negative balance.\n\n"
                   f"**Loan ID**: {new_loan['loan_id']}\n"
                   f"**Amount**: {amount}\n"
                   f"**Amount Due**: {new_loan['amount_due']}\n"
                   f"**Date Due**: {new_loan['due']}")
        await ctx.send(content=message, hidden=True)


class BSEddiesLoanView(BSEddies):
    """
    Class for handling `/bseddies loan view` command
    """
    def __init__(self, client, guilds, logger, beta_mode=False):
        super().__init__(client, guilds, logger, beta_mode=beta_mode)

    async def loan_view(self, ctx: discord_slash.context.SlashContext) -> None:
        """
        Method that handles the slash command.

        We first check if the user has an active loan - but if they don't, we inform them as such.
        Otherwise, we send the user a message with the loan information in.

        :param ctx:
        :return:
        """
        if not await self._handle_validation(ctx):
            return

        self._add_event_type_to_activity_history(ctx.author, ctx.guild_id, ActivityTypes.BSEDDIES_LOAN_VIEW)

        user_id = ctx.author.id
        guild_id = ctx.guild.id

        loan = self.user_loans.get_active_loan_for_user(user_id, guild_id)

        if not loan:
            message = "You have no active loan at the moment. Good on you."
            await ctx.send(content=message, hidden=True)
            return

        message = (f"**Loan ID**: {loan['loan_id']}\n"
                   f"**Amount**: {loan['amount']}\n"
                   f"**Created**: {loan['created']}\n"
                   f"**Amount Due**: {loan['amount_due']}\n"
                   f"**Date Due**: {loan['due']}")
        await ctx.send(content=message, hidden=True)


class BSEddiesLoanRepay(BSEddies):
    """
    Class for handling `/bseddies loan repay` command
    """
    def __init__(self, client, guilds, logger, beta_mode=False):
        super().__init__(client, guilds, logger, beta_mode=beta_mode)

    async def loan_repay(self, ctx: discord_slash.context.SlashContext) -> None:
        """
        Main function for handling loan repayment.

        We check that the user has an active loan to start with - if they don't we tell the user as such.
        We then check if the user has enough eddies to repay the loan - if they don't then we inform them as such.

        If get this far, then we take the eddies out of their account, add to the relevant histories and "resolve" the
        loan.

        :param ctx:
        :return:
        """
        if not await self._handle_validation(ctx):
            return

        self._add_event_type_to_activity_history(ctx.author, ctx.guild_id, ActivityTypes.BSEDDIES_LOAN_REPAY)

        user_id = ctx.author.id
        guild_id = ctx.guild.id

        loan = self.user_loans.get_active_loan_for_user(user_id, guild_id)

        if not loan:
            message = "You have no active loan at the moment. Good on you."
            await ctx.send(content=message, hidden=True)
            return

        user = self.user_points.find_user(user_id, guild_id)

        points = user["points"]
        amount_due = loan["amount_due"]

        if points < amount_due:
            message = f"You don't have enough eddies to pay back your loan yet. You need `{amount_due}`."
            await ctx.send(content=message, hidden=True)
            return

        now = datetime.datetime.now()

        self.user_points.decrement_points(user_id, guild_id, amount_due)
        self.user_loans.close_loan(guild_id, loan["loan_id"], now)

        self.user_points.append_to_transaction_history(
            user_id, guild_id,
            {
                "type": TransactionTypes.LOAN_REPAYMENT,
                "amount": amount_due * -1,
                "timestamp": now,
                "loan_id": loan["loan_id"],
                "comment": "Repaid loan",
            }
        )

        self.user_points.append_to_activity_history(
            user_id, guild_id,
            {
                "type": ActivityTypes.LOAN_REPAYMENT,
                "loan_id": loan["loan_id"],
                "timestamp": now,
                "comment": f"Repaid loan for {amount_due}"
            }
        )

        message = f"Congrats! You've successfully paid your loan back. You owe nothing."
        await ctx.send(content=message, hidden=True)


class BSEddiesAutoGeneratedBets(BSEddies):
    """
    Class for handling `/bseddies bet autogenerate` command
    """

    def __init__(self, client, guilds, logger, beta_mode=False):
        super().__init__(client, guilds, logger, beta_mode=beta_mode)
        self.autobets = AutoGeneratedBets()
        self.bet_create = BSEddiesCreateBet(client, guilds, logger, beta_mode=beta_mode)

    async def generate_bets(self, ctx: discord_slash.context.SlashContext, scenario_type: str) -> None:
        """
        Method to actually handle autogenerating bets

        This is actually quite simple - we take the selected type and look for bets we can generate with that type.

        We then do some filtering - if the bet we have selected has the 'voice_channel' key and 'channel_members' key,
        we double check that all the specified users are in that voice channel. If they're not, then we use a different
        bet.

        And then, we simple use the BSEddiesCreateBet class to actually do all the logic.

        :param ctx:
        :param scenario_type:
        :return:
        """
        if not await self._handle_validation(ctx):
            return

        self._add_event_type_to_activity_history(
            ctx.author, ctx.guild_id, ActivityTypes.BSEDDIES_AUTOGENERATE, scenario_type=scenario_type
        )

        number_of_non_specific_bets = 0
        all_bets = self.autobets.get_bets_for_type(scenario_type)
        bets_to_create = []
        random.shuffle(all_bets)

        max_bets = random.randint(2, 3)

        for pos_bet in all_bets:
            if "voice_channel" not in pos_bet:
                bets_to_create.append(pos_bet)
            else:
                if number_of_non_specific_bets >= 1:
                    continue

                channel_id = pos_bet["voice_channel"]
                channel = await self.client.fetch_channel(channel_id)  # type: discord.VoiceChannel
                online_member_ids = [member.id for member in channel.members]
                if all([m in online_member_ids for m in pos_bet["channel_members"]]):
                    bets_to_create.append(pos_bet)
                    number_of_non_specific_bets += 1

            if len(bets_to_create) == max_bets:
                break

        for bet in bets_to_create:
            await self.bet_create.handle_bet_creation(
                ctx,
                bet["title"],
                *bet["options"],
                timeout_str="15m",
                autogenerated=True
            )


class BSEddiesAdminGive(BSEddies):
    """
    Class for handling `/bseddies admin give` command
    """

    def __init__(self, client, guilds, logger, beta_mode=False):
        super().__init__(client, guilds, logger, beta_mode=beta_mode)

    async def admin_give(self, ctx: discord_slash.context.SlashContext, user: discord.User, amount: int) -> None:
        """
        Command to give a user some extra eddies.
        :param ctx:
        :param user:
        :param amount:
        :return:
        """
        if not await self._handle_validation(ctx, admin=True):
            return

        self._add_event_type_to_activity_history(
            ctx.author, ctx.guild_id, ActivityTypes.BSEDDIES_ADMIN_GIVE, user_id=user.id, amount=amount
        )

        self.user_points.increment_points(user.id, ctx.guild.id, amount)

        self.user_points.append_to_transaction_history(
            user.id, ctx.guild.id,
            {
                "type": TransactionTypes.ADMIN_GIVE,
                "amount": amount,
                "timestamp": datetime.datetime.now(),
                "comment": "Admin override increment"
            }
        )

        try:
            await user.send(content=f"You've been given {amount} eddies by an admin.")
        except discord.Forbidden:
            pass

        await ctx.send(content=f"Given {user.display_name} {amount} eddies.", hidden=True)


class BSEddiesAdminSwitch(BSEddies):
    """
    Class for handling `/bseddies admin give` command
    """

    def __init__(self, client, guilds, logger, beta_mode=False):
        super().__init__(client, guilds, logger, beta_mode=beta_mode)

    async def admin_switch(
            self, ctx: discord_slash.context.SlashContext,
            user: discord.User,
            bet_id: str,
            emoji: str) -> None:
        """
        Command to switch a user's bet on a given BET ID.
        :param ctx:
        :param user:
        :param bet_id:
        :param emoji:
        :return:
        """
        if not await self._handle_validation(ctx, admin=True):
            return

        self._add_event_type_to_activity_history(
            ctx.author, ctx.guild_id, ActivityTypes.BSEDDIES_ADMIN_CHANGE, user_id=user.id, bet_id=bet_id, emoji=emoji
        )

        bet = self.user_bets.get_bet_from_id(ctx.guild.id, bet_id)
        if not bet:
            return

        betters = bet["betters"]
        if str(user.id) not in betters:
            await ctx.send(content="User hasn't bet on this bet.", hidden=True)
            return

        if emoji not in bet["options"]:
            await ctx.send(content="This emoji isn't in the bet options", hidden=True)
            return

        self.user_bets.update({"_id": bet["_id"]}, {"$set": {f"betters.{user.id}.emoji": emoji}})

        guild = self.client.get_guild(ctx.guild.id)  # type: discord.Guild

        embed = self.embed_manager.get_bet_embed(guild, bet["bet_id"], bet)

        channel = guild.get_channel(bet["channel_id"])  # type: discord.TextChannel
        message = await channel.fetch_message(bet["message_id"])

        await ctx.send(content="Success!", hidden=True)
        await message.edit(embed=embed)


class BSEddiesKing(BSEddies):
    """
        Class for handling `/bseddies admin give` command
        """

    def __init__(self, client, guilds, logger, beta_mode=False):
        super().__init__(client, guilds, logger, beta_mode=beta_mode)

    async def king_data(self, ctx: discord_slash.context.SlashContext) -> None:
        """

        :param ctx:
        :return:
        """
        if not await self._handle_validation(ctx):
            return

        self._add_event_type_to_activity_history(ctx.author, ctx.guild_id, ActivityTypes.BSEDDIES_KING)

        guild_id = ctx.guild.id

        king_user = self.user_points.get_current_king(guild_id)
        data = self.user_points.get_king_info(king_user)

        role_id = BSEDDIES_KING_ROLES[guild_id]
        role = ctx.guild.get_role(role_id)
        member = ctx.guild.get_member(king_user["uid"])  # type: discord.Member

        message = (f"**King Info**\n"
                   f"{member.mention} is our current {role.mention}. They've been King for "
                   f"{str(datetime.timedelta(seconds=data['current']))}.\n\n"
                   f"The total amount of time they've spent as KING is "
                   f"`{str(datetime.timedelta(seconds=data['total']))}`\n"
                   f"They've been {role.mention} **{data['times']}** times.\n"
                   f"The longest they've been {role.mention} for is "
                   f"{str(datetime.timedelta(seconds=max(data['all_times'])))}")
        await ctx.send(content=message)


class BSEServerTurnOn(BaseEvent):
    def __init__(self, client, guilds, logger, task):
        super().__init__(client, guilds, logger)
        self.task = task  # type: ServerInfo
        self.aws = AWSAPI()

    async def turn_server_on(self, ctx: discord_slash.context.SlashContext) -> None:
        """

        :param ctx:
        :return:
        """

        if ctx.author.id != CREATOR:
            await ctx.send(content="You lack the permissions for this.", hidden=True)
            return

        instance = self.aws.get_instance(AWS_GAME_SERVER_INSTANCE)

        if instance.state["Code"] != 80:
            self.task.server_info.change_interval(seconds=15)
            await ctx.send(content="Instance isn't `stopped` so I cannot start it for you.", hidden=True)
            return

        start = self.aws.start_instance(AWS_GAME_SERVER_INSTANCE)
        guild = self.client.get_guild(BSE_SERVER_ID)
        channel = guild.get_channel(BSE_SERVER_INFO_CHANNEL)  # type: discord.TextChannel

        self.task.server_info.change_interval(seconds=15)
        self.task.server_info.restart()

        if channel:
            mention = channel.mention
        else:
            mention = "info channel"

        await ctx.send(
            content=f"Successfully started AWS instance for you. Please check {mention} for status.",
            hidden=True
        )


class BSEServerTurnOff(BaseEvent):
    def __init__(self, client, guilds, logger, task):
        super().__init__(client, guilds, logger)
        self.task = task  # type: ServerInfo
        self.aws = AWSAPI()
        self.game_server_info = GameServerInfo()

    async def turn_server_off(self, ctx: discord_slash.context.SlashContext) -> None:
        """

        :param ctx:
        :return:
        """

        if ctx.author.id != CREATOR:
            await ctx.send(content="You lack the permissions for this.", hidden=True)
            return

        instance = self.aws.get_instance(AWS_GAME_SERVER_INSTANCE)
        if instance.state["Code"] != 16:
            await ctx.send(content="Instance isn't `running` so I cannot stop it for you.", hidden=True)
            return

        if self.game_server_info.get_player_count() > 0:
            await ctx.send(content="Can't turn off instance when there are connected players.", hidden=True)
            return

        stopped = self.aws.stop_instance(AWS_GAME_SERVER_INSTANCE)
        guild = self.client.get_guild(BSE_SERVER_ID)
        channel = guild.get_channel(BSE_SERVER_INFO_CHANNEL)  # type: discord.TextChannel
        self.task.server_info.restart()

        if channel:
            mention = channel.mention
        else:
            mention = "info channel"

        await ctx.send(
            content=f"Successfully stopped AWS instance for you. Please check {mention} for status.",
            hidden=True
        )


class BSEToggleGameService(BaseEvent):
    def __init__(self, client, guilds, logger, task):
        super().__init__(client, guilds, logger)
        self.task = task  # type: ServerInfo
        self.aws = AWSAPI()
        self.toggle_on_commands = {
            "valheim": "sudo systemctl start valheimserver.service",
            "minecraft_base": "docker start bse_mc_base",
            "minecraft_hardcore": "docker start bse_mc_hardcore_iii",
        }
        self.toggle_off_commands = {
            "valheim": "sudo systemctl stop valheimserver.service",
            "minecraft_base": "docker stop bse_mc_base",
            "minecraft_hardcore": "docker stop bse_mc_hardcore_iii",
        }

    async def toggle_game_service(
            self,
            ctx: discord_slash.context.SlashContext,
            server: str,
            toggle: bool) -> None:
        """

        :param ctx:
        :param server:
        :param toggle:
        :return:
        """

        if ctx.author.id != CREATOR:
            await ctx.send(content="You lack the permissions for this.", hidden=True)
            return

        instance = self.aws.get_instance(AWS_GAME_SERVER_INSTANCE)

        if instance.state["Name"] != "running":
            await ctx.send(
                content="The instance isn't 'running' yet - please start the server or give it a minute",
                hidden=True
            )
            return

        cmd_d = self.toggle_on_commands if toggle else self.toggle_off_commands

        if not toggle:
            # insert logic here to see if there's people connected
            pass

        cmd = cmd_d[server]
        try:
            async with asyncssh.connect("awsgames") as conn:
                result = await conn.run(cmd, check=True)
        except ConnectionRefusedError:
            await ctx.send(
                content="The instance isn't 'running' yet - please start the server or give it a minute",
                hidden=True
            )
            return

        guild = self.client.get_guild(BSE_SERVER_ID)
        channel = guild.get_channel(BSE_SERVER_INFO_CHANNEL)  # type: discord.TextChannel

        self.task.server_info.change_interval(seconds=15)
        self.task.server_info.restart()

        if channel:
            mention = channel.mention
        else:
            mention = "info channel"

        word = "started" if toggle else "stopped"

        await ctx.send(
            content=f"Successfully {word} {server} for you. Please check {mention} for status.",
            hidden=True
        )
