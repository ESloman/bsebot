
import discord
from bson import ObjectId

from discordbot.slashcommandeventclasses.bseddies import BSEddies
from discordbot.slashcommandeventclasses.close import CloseBet
from discordbot.slashcommandeventclasses.create import CreateBet
from discordbot.slashcommandeventclasses.place import PlaceBet
from discordbot.views.autogenerate import AutoGenerateView

from discordbot.bot_enums import ActivityTypes
from mongo.bsedataclasses import AutoGeneratedBets


class AutoGenerate(BSEddies):
    """
    Class for handling `/autogenerate` commands
    """

    def __init__(self, client, guilds, logger):
        super().__init__(client, guilds, logger)
        self.bet = CreateBet(client, guilds, logger)
        self.auto_bets = AutoGeneratedBets()
        self.place = PlaceBet(client, guilds, logger)
        self.close = CloseBet(client, guilds, logger)

    async def create_auto_generate_view(self, ctx: discord.ApplicationContext):
        view = AutoGenerateView(self)
        await ctx.followup.send(view=view, ephemeral=True)

    async def autogenerate_wrapper(
            self,
            ctx,
            _type: str,
            method: str,
            number: int,
            bet_ids: list,
            timeout_str: str = "30m",
            channel: int = None
    ) -> None:

        self._add_event_type_to_activity_history(
            ctx.user, ctx.guild_id, ActivityTypes.BSEDDIES_AUTOGENERATE
        )

        if method == "random":
            validated_bets = []
            while method == "random" and len(validated_bets) < int(number):
                # grab more than required in the hopes that we only have to do one API call to mongo here
                bets = self.auto_bets.get_random_bets_for_type(_type, int(number) + 2)
                for bet in bets:
                    if len(validated_bets) == int(number):
                        # got the number requested already
                        break
                    if bet in validated_bets:
                        # already got this one
                        continue
                    if not bet.get("channel_members"):
                        validated_bets.append(bet)
                        continue
                    # validate that we can use this bet
                    vc_channel = await self.client.fetch_channel(channel)
                    member_ids = [m.id for m in vc_channel.members]
                    if not all([c_m in member_ids for c_m in bet["channel_members"]]):
                        self.logger.info(f"Can't use bet {bet} as not all required members are present")
                        continue
                    validated_bets.append(bet)
        else:
            validated_bets = self.auto_bets.query({"type": _type, "_id": {"$in": [ObjectId(b) for b in bet_ids]}})

        bets = sorted(validated_bets, key=lambda x: x["title"])

        for bet in bets:
            try:
                if not bet["options"] and bet.get("voice_channel"):
                    # bet has no options but should be constructed from channel members
                    vc_channel = await self.client.fetch_channel(channel)
                    for member in vc_channel.members:
                        bet["options"].append(member.display_name)

                    if bet["type"] == "valorant" and len(bet["options"]) < 5 and bet.get("fill"):
                        bet["options"].append("a rando")

            except Exception as e:
                self.logger.info(f"Something went wrong creating an auto bet: {e}, {bet}")
                continue

            await self.bet.handle_bet_creation(
                ctx,
                bet["title"],
                *bet["options"],
                timeout_str=timeout_str,
                autogenerated=True,
                bseddies_place=self.place,
                bseddies_close=self.close
            )
