"""Autogenerate slash command."""

import copy
import logging
from typing import TYPE_CHECKING

import discord
from bson import ObjectId

from discordbot.bot_enums import ActivityTypes
from discordbot.bsebot import BSEBot
from discordbot.slashcommandeventclasses.bseddies import BSEddies
from discordbot.slashcommandeventclasses.close import CloseBet
from discordbot.slashcommandeventclasses.create import CreateBet
from discordbot.slashcommandeventclasses.place import PlaceBet
from discordbot.views.autogenerate import AutoGenerateView
from mongo.bsedataclasses import AutoGeneratedBets

if TYPE_CHECKING:
    from mongo.datatypes.autogeneratedbets import AutoGeneratedBetDB


class AutoGenerate(BSEddies):
    """Class for handling `/autogenerate` commands."""

    def __init__(self, client: BSEBot, guild_ids: list[int], logger: logging.Logger) -> None:
        """Initialisation method.

        Args:
            client (BSEBot): the connected BSEBot client
            guild_ids (list): list of supported guild IDs
            logger (logging.Logger): the logger
        """
        super().__init__(client, guild_ids, logger)
        self.bet = CreateBet(client, guild_ids, logger)
        self.auto_bets = AutoGeneratedBets()
        self.place = PlaceBet(client, guild_ids, logger)
        self.close = CloseBet(client, guild_ids, logger)
        self.activity_type = ActivityTypes.BSEDDIES_AUTOGENERATE
        self.help_string = "Autogenerates bets based on chosen parameters"
        self.command_name = "autogenerate"

    async def create_auto_generate_view(self, ctx: discord.ApplicationContext) -> None:
        """Creates the view.

        Args:
            ctx (discord.ApplicationContext): the context
        """
        view = AutoGenerateView(self)
        await ctx.followup.send(view=view, ephemeral=True)

    async def autogenerate_wrapper(  # noqa: C901, PLR0912, PLR0913, PLR0917
        self,
        ctx: discord.ApplicationContext,
        _type: str,
        method: str,
        number: int,
        bet_ids: list[str],
        timeout_str: str = "30m",
        channel: int | None = None,
    ) -> None:
        """Autogenerate wrapper.

        Args:
            ctx (discord.ApplicationContext): the context
            _type (str): the type of bets to generate
            method (str): how to generate the bets
            number (int): number of bets to generate
            bet_ids (list): the bet IDs
            timeout_str (str, optional): the timeout str. Defaults to "30m".
            channel (int | None, optional): the channel to populate values from. Defaults to None.
        """
        self._add_event_type_to_activity_history(ctx.user, ctx.guild_id, ActivityTypes.BSEDDIES_AUTOGENERATE)

        validated_bets: list[AutoGeneratedBetDB] = []
        if method == "random":
            while len(validated_bets) < int(number):
                # grab more than required in the hopes that we only have to do one API call to mongo here
                bets = self.auto_bets.get_random_bets_for_type(_type, int(number) + 2)
                for bet in bets:
                    if len(validated_bets) == int(number):
                        # got the number requested already
                        break
                    if bet in validated_bets:
                        # already got this one
                        continue
                    if not bet.channel_members:
                        validated_bets.append(bet)
                        continue
                    # validate that we can use this bet
                    vc_channel = await self.client.fetch_channel(channel)
                    member_ids = [m.id for m in vc_channel.members]
                    if not all(c_m in member_ids for c_m in bet.channel_members):
                        self.logger.info("Can't use bet %s as not all required members are present", bet)
                        continue
                    validated_bets.append(bet)
        else:
            validated_bets = self.auto_bets.query({"type": _type, "_id": {"$in": [ObjectId(b) for b in bet_ids]}})

        bets = sorted(validated_bets, key=lambda x: x.title)

        for bet in bets:
            options = copy.deepcopy(bet.options)
            try:
                if not bet.options and bet.voice_channel:
                    # bet has no options but should be constructed from channel members
                    vc_channel = await self.client.fetch_channel(channel)
                    for member in vc_channel.members:
                        options.append(member.display_name)

                    if bet.type == "valorant" and len(options) < 5 and bet.fill:  # noqa: PLR2004
                        options.append("a rando")

            except Exception as e:
                self.logger.info("Something went wrong creating an auto bet: %s, %s", e, bet)
                continue

            await self.bet.handle_bet_creation(
                ctx,
                bet["title"],
                *bet["options"],
                timeout_str=timeout_str,
                autogenerated=True,
                bseddies_place=self.place,
                bseddies_close=self.close,
            )
