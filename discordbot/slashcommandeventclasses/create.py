"""Create slash command."""

import contextlib
import datetime
import logging

import discord

from discordbot import utilities
from discordbot.bot_enums import ActivityTypes
from discordbot.bsebot import BSEBot
from discordbot.slashcommandeventclasses.bseddies import BSEddies
from discordbot.views.bet import BetView


class CreateBet(BSEddies):
    """Class for handling `/bseddies bet create` command."""

    def __init__(self, client: BSEBot, guild_ids: list, logger: logging.Logger) -> None:
        """Initialisation method.

        Args:
            client (BSEBot): the connected BSEBot client
            guild_ids (list): list of supported guild IDs
            logger (logging.Logger): the logger
        """
        super().__init__(client, guild_ids, logger)
        self.multiple_options_emojis = ["1️⃣", "2️⃣", "3️⃣", "4️⃣", "5️⃣", "6️⃣", "7️⃣", "8️⃣", "9️⃣", "0️⃣"]
        self.activity_type = ActivityTypes.BSEDDIES_BET_CREATE
        self.help_string = "Creates a bet"
        self.command_name = "create"

    async def handle_bet_creation(  # noqa: C901, PLR0913, PLR0912, PLR0917
        self,
        ctx: discord.ApplicationContext | discord.Interaction,
        bet_title: str,
        option_one_name: str | None = None,
        option_two_name: str | None = None,
        option_three_name: str | None = None,
        option_four_name: str | None = None,
        option_five_name: str | None = None,
        option_six_name: str | None = None,
        option_seven_name: str | None = None,
        option_eight_name: str | None = None,
        option_nine_name: str | None = None,
        option_ten_name: str | None = None,
        timeout_str: str | None = None,
        autogenerated: bool = False,
        bseddies_place: object | None = None,
        bseddies_close: object | None = None,
    ) -> None:
        """The method that handles bet creation.

        We work out which outcome names we're gonna need - either custom or defaults.
        We make sure the user provided the right timeout or outcomes names (if at all).
        We then set the timeout for the bet.
        And we also work out which outcome emojis to use based of of the number of provided outcomes.

        Then we create the bet and send a message to channel the bet was created in.

        Args:
            PLR0913 (_type_): _description_
            PLR0912self (_type_): _description_
            ctx (discord.ApplicationContext | discord.Interaction): _description_
            bet_title (str): _description_
            option_one_name (str | None, optional): _description_. Defaults to None.
            option_two_name (str | None, optional): _description_. Defaults to None.
            option_three_name (str | None, optional): _description_. Defaults to None.
            option_four_name (str | None, optional): _description_. Defaults to None.
            option_five_name (str | None, optional): _description_. Defaults to None.
            option_six_name (str | None, optional): _description_. Defaults to None.
            option_seven_name (str | None, optional): _description_. Defaults to None.
            option_eight_name (str | None, optional): _description_. Defaults to None.
            option_nine_name (str | None, optional): _description_. Defaults to None.
            option_ten_name (str | None, optional): _description_. Defaults to None.
            timeout_str (str | None, optional): _description_. Defaults to None.
            autogenerated (bool, optional): _description_. Defaults to False.
            bseddies_place (object | None, optional): _description_. Defaults to None.
            bseddies_close (object | None, optional): _description_. Defaults to None.
        """
        if not await self._handle_validation(ctx):
            return

        with contextlib.suppress(Exception):
            await ctx.response.defer(ephemeral=True)

        self._add_event_type_to_activity_history(
            ctx.user,
            ctx.guild_id,
            ActivityTypes.BSEDDIES_BET_CREATE,
            bet_title=bet_title,
            option_one_name=option_one_name,
            option_two_name=option_two_name,
            option_three_name=option_three_name,
            option_four_name=option_four_name,
            option_five_name=option_five_name,
            option_six_name=option_six_name,
            autogenerated=autogenerated,
            timeout_str=timeout_str,
        )

        if not option_one_name or not option_two_name:
            msg = (
                "If you're providing custom outcome names - you must provide at least two outcomes.\n"
                "Additionally, you must provide the outcomes sequentially "
                "(ie, outcome_one, then outcome_two, and then outcome_three, and then outcome_four.)"
            )
            await ctx.followup.send(content=msg, ephemeral=True)
            return

        option_dict = {
            self.multiple_options_emojis[0]: {"val": option_one_name},
            self.multiple_options_emojis[1]: {"val": option_two_name},
        }

        if option_three_name:
            option_dict[self.multiple_options_emojis[2]] = {"val": option_three_name}
        if option_four_name:
            option_dict[self.multiple_options_emojis[3]] = {"val": option_four_name}
        if option_five_name:
            option_dict[self.multiple_options_emojis[4]] = {"val": option_five_name}
        if option_six_name:
            option_dict[self.multiple_options_emojis[5]] = {"val": option_six_name}
        if option_seven_name:
            option_dict[self.multiple_options_emojis[6]] = {"val": option_seven_name}
        if option_eight_name:
            option_dict[self.multiple_options_emojis[7]] = {"val": option_eight_name}
        if option_nine_name:
            option_dict[self.multiple_options_emojis[8]] = {"val": option_nine_name}
        if option_ten_name:
            option_dict[self.multiple_options_emojis[8]] = {"val": option_ten_name}

        if timeout_str is None:
            timeout = datetime.datetime.now() + datetime.timedelta(minutes=10)
        else:
            timeout_str = timeout_str.strip()
            try:
                _seconds = utilities.convert_time_str(timeout_str)
            except Exception as exc:
                # leaving Exception in for now until we're sure that all exception types have been caught
                if type(exc) not in {IndexError, AttributeError}:
                    self.logger.debug("Got an error with a timestring: %s", exc)
                _seconds = None

            if not _seconds:
                msg = (
                    "Your timeout string was incorrectly formatted. Needs to be 1 - 5 digits "
                    "and then either a s, m, h, or d "
                    "to signify seconds, minutes, hours, or days respectively."
                )
                await ctx.followup.send(content=msg, ephemeral=True)
                return

            timeout = datetime.datetime.now() + datetime.timedelta(seconds=_seconds)

        await ctx.channel.trigger_typing()

        bet = self.user_bets.create_new_bet(
            ctx.guild.id,
            ctx.user.id,
            bet_title,
            options=list(option_dict.keys()),
            option_dict=option_dict,
            timeout=timeout,
        )

        embed = self.embed_manager.get_bet_embed(ctx.guild, bet)
        content = f"# {bet['title']}\n_Created by <@{bet['user']}>_"

        bet_view = BetView(bet, bseddies_place, bseddies_close)

        message = await ctx.channel.send(content=content, embed=embed, view=bet_view)

        self.user_bets.update(
            {"_id": bet["_id"]},
            {"$set": {"message_id": message.id, "channel_id": message.channel.id}},
        )

        await ctx.followup.send(content="Created bet for you.", ephemeral=True, delete_after=5)
