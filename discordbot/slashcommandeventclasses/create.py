
import datetime
from typing import Union

import discord

from discordbot import utilities
from discordbot.bot_enums import ActivityTypes
from discordbot.slashcommandeventclasses.bseddies import BSEddies
from discordbot.views.bet import BetView


class CreateBet(BSEddies):
    """
    Class for handling `/bseddies bet create` command
    """

    def __init__(self, client, guilds, logger):
        super().__init__(client, guilds, logger)
        self.multiple_options_emojis = ["1️⃣", "2️⃣", "3️⃣", "4️⃣", "5️⃣", "6️⃣", "7️⃣", "8️⃣", "9️⃣", "0️⃣"]
        self.activity_type = ActivityTypes.BSEDDIES_BET_CREATE
        self.help_string = "Creates a bet"
        self.command_name = "create"

    async def handle_bet_creation(
            self,
            ctx: Union[discord.ApplicationContext, discord.Interaction],
            bet_title: str,
            option_one_name: Union[str, None] = None,
            option_two_name: Union[str, None] = None,
            option_three_name: Union[str, None] = None,
            option_four_name: Union[str, None] = None,
            option_five_name: Union[str, None] = None,
            option_six_name: Union[str, None] = None,
            option_seven_name: Union[str, None] = None,
            option_eight_name: Union[str, None] = None,
            option_nine_name: Union[str, None] = None,
            option_ten_name: Union[str, None] = None,
            timeout_str: Union[str, None] = None,
            autogenerated: bool = False,
            bseddies_place=None,
            bseddies_close=None
    ) -> None:
        """
        The method that handles bet creation.

        We work out which outcome names we're gonna need - either custom or defaults.
        We make sure the user provided the right timeout or outcomes names (if at all).
        We then set the timeout for the bet.
        And we also work out which outcome emojis to use based of of the number of provided outcomes.

        Then we create the bet and send a message to channel the bet was created in.

        :param bseddies_place:
        :param bseddies_close:
        :param ctx:
        :param bet_title:
        :param option_one_name:
        :param option_two_name:
        :param option_three_name:
        :param option_four_name:
        :param option_six_name:
        :param option_five_name:
        :param option_seven_name:
        :param option_eight_name:
        :param option_nine_name:
        :param option_ten_name:
        :param timeout_str:
        :param autogenerated:
        :return:
        """
        if not await self._handle_validation(ctx):
            return

        try:
            await ctx.response.defer(ephemeral=True)
        except Exception:
            pass

        self._add_event_type_to_activity_history(
            ctx.user, ctx.guild_id, ActivityTypes.BSEDDIES_BET_CREATE,
            bet_title=bet_title, option_one_name=option_one_name, option_two_name=option_two_name,
            option_three_name=option_three_name, option_four_name=option_four_name, option_five_name=option_five_name,
            option_six_name=option_six_name, autogenerated=autogenerated, timeout_str=timeout_str
        )

        if not option_one_name or not option_two_name:
            msg = ("If you're providing custom outcome names - you must provide at least two outcomes.\n"
                   "Additionally, you must provide the outcomes sequentially "
                   "(ie, outcome_one, then outcome_two, and then outcome_three, and then outcome_four.)")
            await ctx.followup.send(content=msg, ephemeral=True)
            return

        option_dict = {
            self.multiple_options_emojis[0]: {"val": option_one_name},
            self.multiple_options_emojis[1]: {"val": option_two_name},
        }

        if option_three_name:
            option_dict[self.multiple_options_emojis[2]] = {"val": option_three_name}
        if option_four_name:
            option_dict[self.multiple_options_emojis[3]] = {"val": option_four_name}
        if option_five_name:
            option_dict[self.multiple_options_emojis[4]] = {"val": option_five_name}
        if option_six_name:
            option_dict[self.multiple_options_emojis[5]] = {"val": option_six_name}
        if option_seven_name:
            option_dict[self.multiple_options_emojis[6]] = {"val": option_seven_name}
        if option_eight_name:
            option_dict[self.multiple_options_emojis[7]] = {"val": option_eight_name}
        if option_nine_name:
            option_dict[self.multiple_options_emojis[8]] = {"val": option_nine_name}
        if option_ten_name:
            option_dict[self.multiple_options_emojis[8]] = {"val": option_ten_name}

        if timeout_str is None:
            timeout = datetime.datetime.now() + datetime.timedelta(minutes=10)
        else:
            timeout_str = timeout_str.strip()
            try:
                _seconds = utilities.convert_time_str(timeout_str)
            except (IndexError, AttributeError, Exception) as e:
                # leaving Exception in for now until we're sure that all exception types have been caught
                if type(e) not in (IndexError, AttributeError):
                    self.logger.debug(f"Got an error with a timestring: {e}")
                _seconds = None

            if not _seconds:
                msg = ("Your timeout string was incorrectly formatted. Needs to be 1 - 5 digits "
                       "and then either a s, m, h, or d "
                       "to signify seconds, minutes, hours, or days respectively.")
                await ctx.followup.send(content=msg, ephemeral=True)
                return

            timeout = datetime.datetime.now() + datetime.timedelta(seconds=_seconds)

        await ctx.channel.trigger_typing()

        bet = self.user_bets.create_new_bet(
            ctx.guild.id,
            ctx.user.id,
            bet_title,
            options=list(option_dict.keys()),
            option_dict=option_dict,
            timeout=timeout
        )

        embed = self.embed_manager.get_bet_embed(ctx.guild, bet["bet_id"], bet)
        content = (
            f"# {bet['title']}\n"
            f"_Created by <@{bet['user']}>_"
        )

        bet_view = BetView(bet, bseddies_place, bseddies_close)

        message = await ctx.channel.send(content=content, embed=embed, view=bet_view)

        self.user_bets.update(
            {"_id": bet["_id"]},
            {"$set": {"message_id": message.id, "channel_id": message.channel.id}}
        )

        await ctx.followup.send(content="Created bet for you.", ephemeral=True, delete_after=5)
