
import datetime
import re
from typing import Union

import discord

import discordbot.views as views
from discordbot.bot_enums import ActivityTypes
from discordbot.constants import PRIVATE_CHANNEL_IDS
from discordbot.slashcommandeventclasses import BSEddies


class BSEddiesCreateBet(BSEddies):
    """
    Class for handling `/bseddies bet create` command
    """

    def __init__(self, client, guilds, logger):
        super().__init__(client, guilds, logger)
        self.multiple_options_emojis = ["1️⃣", "2️⃣", "3️⃣", "4️⃣", "5️⃣", "6️⃣", "7️⃣", "8️⃣", "9️⃣", "0️⃣"]

    async def handle_bet_creation(
            self,
            ctx: Union[discord.ApplicationContext, discord.Interaction],
            bet_title: str,
            option_one_name: Union[str, None] = None,
            option_two_name: Union[str, None] = None,
            option_three_name: Union[str, None] = None,
            option_four_name: Union[str, None] = None,
            option_five_name: Union[str, None] = None,
            option_six_name: Union[str, None] = None,
            option_seven_name: Union[str, None] = None,
            option_eight_name: Union[str, None] = None,
            option_nine_name: Union[str, None] = None,
            option_ten_name: Union[str, None] = None,
            timeout_str: Union[str, None] = None,
            autogenerated: bool = False,
            bseddies_place=None,
            bseddies_close=None
    ) -> None:
        """
        The method that handles bet creation.

        We work out which outcome names we're gonna need - either custom or defaults.
        We make sure the user provided the right timeout or outcomes names (if at all).
        We then set the timeout for the bet.
        And we also work out which outcome emojis to use based of of the number of provided outcomes.

        Then we create the bet and send a message to channel the bet was created in.

        :param bseddies_place:
        :param bseddies_close:
        :param ctx:
        :param bet_title:
        :param option_one_name:
        :param option_two_name:
        :param option_three_name:
        :param option_four_name:
        :param option_six_name:
        :param option_five_name:
        :param option_seven_name:
        :param option_eight_name:
        :param option_nine_name:
        :param option_ten_name:
        :param timeout_str:
        :param autogenerated:
        :return:
        """
        if not await self._handle_validation(ctx):
            return

        try:
            await ctx.response.defer(ephemeral=True)
        except Exception as e:
            pass

        self._add_event_type_to_activity_history(
            ctx.user, ctx.guild_id, ActivityTypes.BSEDDIES_BET_CREATE,
            bet_title=bet_title, option_one_name=option_one_name, option_two_name=option_two_name,
            option_three_name=option_three_name, option_four_name=option_four_name, option_five_name=option_five_name,
            option_six_name=option_six_name, autogenerated=autogenerated, timeout_str=timeout_str
        )

        if not option_one_name or not option_two_name:
            msg = (f"If you're providing custom outcome names - you must provide at least two outcomes.\n"
                   f"Additionally, you must provide the outcomes sequentially "
                   f"(ie, outcome_one, then outcome_two, and then outcome_three, and then outcome_four.)")
            await ctx.respond(content=msg, ephemeral=True)
            return

        option_dict = {
            self.multiple_options_emojis[0]: {"val": option_one_name},
            self.multiple_options_emojis[1]: {"val": option_two_name},
        }

        if option_three_name:
            option_dict[self.multiple_options_emojis[2]] = {"val": option_three_name}
        if option_four_name:
            option_dict[self.multiple_options_emojis[3]] = {"val": option_four_name}
        if option_five_name:
            option_dict[self.multiple_options_emojis[4]] = {"val": option_five_name}
        if option_six_name:
            option_dict[self.multiple_options_emojis[5]] = {"val": option_six_name}
        if option_seven_name:
            option_dict[self.multiple_options_emojis[6]] = {"val": option_seven_name}
        if option_eight_name:
            option_dict[self.multiple_options_emojis[7]] = {"val": option_eight_name}
        if option_nine_name:
            option_dict[self.multiple_options_emojis[8]] = {"val": option_nine_name}
        if option_ten_name:
            option_dict[self.multiple_options_emojis[8]] = {"val": option_ten_name}

        if timeout_str is None:
            timeout = datetime.datetime.now() + datetime.timedelta(minutes=10)
        else:
            timeout_str = timeout_str.strip()
            match = re.match(r"\d{1,5}([smhd])", timeout_str)
            if not match:
                msg = ("Your timeout string was incorrectly formatted. Needs to be 1 - 5 digits "
                       "and then either a s, m, h, or d "
                       "to signify seconds, minutes, hours, or days respectively.")
                await ctx.respond(content=msg, ephemeral=True)
                return
            g = match.group()
            if "s" in g:
                dt_key = {"seconds": int(g.replace("s", ""))}
            elif "m" in g:
                dt_key = {"minutes": int(g.replace("m", ""))}
            elif "h" in g:
                dt_key = {"hours": int(g.replace("h", ""))}
            elif "d" in g:
                dt_key = {"days": int(g.replace("d", ""))}
            else:
                dt_key = {}
            timeout = datetime.datetime.now() + datetime.timedelta(**dt_key)

        private = ctx.channel_id in PRIVATE_CHANNEL_IDS

        bet = self.user_bets.create_new_bet(
            ctx.guild.id,
            ctx.user.id,
            bet_title,
            options=list(option_dict.keys()),
            option_dict=option_dict,
            timeout=timeout,
            private=private
        )

        embed = self.embed_manager.get_bet_embed(ctx.guild, bet["bet_id"], bet)

        member = ctx.guild.get_member(ctx.user.id)
        content = f"Bet created by {member.mention}"

        bet_view = views.BetView(bet, bseddies_place, bseddies_close)

        # await ctx.send(content=f"Bet created: {bet_title}", hidden=True)
        message = await ctx.channel.send(content=content, embed=embed, view=bet_view)

        self.user_bets.update(
            {"_id": bet["_id"]},
            {"$set": {"message_id": message.id, "channel_id": message.channel.id}}
        )

        await ctx.followup.send(content="Created bet for you.", ephemeral=True)
