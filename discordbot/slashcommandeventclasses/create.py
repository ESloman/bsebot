"""Create slash command."""

import contextlib
import datetime
from typing import TYPE_CHECKING
from zoneinfo import ZoneInfo

import discord

from discordbot import utilities
from discordbot.bot_enums import ActivityTypes
from discordbot.bsebot import BSEBot
from discordbot.slashcommandeventclasses.bseddies import BSEddies
from discordbot.views.bet import BetView

if TYPE_CHECKING:
    from discordbot.slashcommandeventclasses.close import CloseBet
    from discordbot.slashcommandeventclasses.place import PlaceBet


class CreateBet(BSEddies):
    """Class for handling `/bseddies bet create` command."""

    def __init__(self, client: BSEBot) -> None:
        """Initialisation method.

        Args:
            client (BSEBot): the connected BSEBot client

        """
        super().__init__(client)
        self.multiple_options_emojis = ["1️⃣", "2️⃣", "3️⃣", "4️⃣", "5️⃣", "6️⃣", "7️⃣", "8️⃣", "9️⃣", "0️⃣"]
        self.activity_type = ActivityTypes.BSEDDIES_BET_CREATE
        self.help_string = "Creates a bet"
        self.command_name = "create"

    async def handle_bet_creation(  # noqa: PLR0913, PLR0917
        self,
        ctx: discord.ApplicationContext | discord.Interaction,
        bet_title: str,
        options: list[str | None],
        timeout_str: str | None = None,
        autogenerated: bool = False,
        bseddies_place: "PlaceBet | None" = None,
        bseddies_close: "CloseBet | None" = None,
    ) -> None:
        """The method that handles bet creation.

        We work out which outcome names we're gonna need - either custom or defaults.
        We make sure the user provided the right timeout or outcomes names (if at all).
        We then set the timeout for the bet.
        And we also work out which outcome emojis to use based of of the number of provided outcomes.

        Then we create the bet and send a message to channel the bet was created in.

        Args:
            ctx (discord.ApplicationContext | discord.Interaction): the context
            bet_title (str): the bet title
            options (list[str | None]). list of options.
            timeout_str (str | None, optional): _description_. Defaults to None.
            autogenerated (bool, optional): _description_. Defaults to False.
            bseddies_place (PlaceBet | None): the place command. Defaults to None.
            bseddies_close (CloseBet | None): the close command. Defaults to None.
        """
        if not await self._handle_validation(ctx):
            return

        with contextlib.suppress(Exception):
            await ctx.response.defer(ephemeral=True)

        # pad the length of options
        if len(options) < 10:  # noqa: PLR2004
            options += [None] * (10 - len(options))

        self._add_event_type_to_activity_history(
            ctx.user,
            ctx.guild_id,
            ActivityTypes.BSEDDIES_BET_CREATE,
            bet_title=bet_title,
            options=options,
            autogenerated=autogenerated,
            timeout_str=timeout_str,
        )

        if not options[0] or not options[1]:
            msg = (
                "If you're providing custom outcome names - you must provide at least two outcomes.\n"
                "Additionally, you must provide the outcomes sequentially "
                "(ie, outcome_one, then outcome_two, and then outcome_three, and then outcome_four.)"
            )
            await ctx.followup.send(content=msg, ephemeral=True)
            return

        option_dict = {
            self.multiple_options_emojis[idx]: {"val": option_name}
            for idx, option_name in enumerate(options)
            if option_name
        }

        if timeout_str is None:
            timeout = datetime.datetime.now(tz=ZoneInfo("UTC")) + datetime.timedelta(minutes=10)
        else:
            timeout_str = timeout_str.strip()
            try:
                _seconds = utilities.convert_time_str(timeout_str)
            except Exception as exc:
                # leaving Exception in for now until we're sure that all exception types have been caught
                if type(exc) not in {IndexError, AttributeError}:
                    self.logger.debug("Got an error with a timestring: %s", exc)
                _seconds = None

            if not _seconds:
                msg = (
                    "Your timeout string was incorrectly formatted. Needs to be 1 - 5 digits "
                    "and then either a s, m, h, or d "
                    "to signify seconds, minutes, hours, or days respectively."
                )
                await ctx.followup.send(content=msg, ephemeral=True)
                return

            timeout = datetime.datetime.now(tz=ZoneInfo("UTC")) + datetime.timedelta(seconds=_seconds)

        await ctx.channel.trigger_typing()

        bet = self.user_bets.create_new_bet(
            ctx.guild.id,
            ctx.user.id,
            bet_title,
            options=list(option_dict.keys()),
            option_dict=option_dict,
            timeout=timeout,
        )

        embed = self.embed_manager.get_bet_embed(bet)
        content = f"# {bet.title}\n_Created by <@{bet.user}>_"

        bet_view = BetView(bet, bseddies_place, bseddies_close)

        message = await ctx.channel.send(content=content, embed=embed, view=bet_view)

        self.user_bets.update(
            {"_id": bet._id},  # noqa: SLF001
            {"$set": {"message_id": message.id, "channel_id": message.channel.id}},
        )

        await ctx.followup.send(content="Created bet for you.", ephemeral=True, delete_after=5)
