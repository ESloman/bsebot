
import datetime
import math

import discord
from discord import SelectOption, Interaction

from discordbot.bot_enums import ActivityTypes, TransactionTypes
from discordbot.constants import BSEDDIES_KING_ROLES, BSE_SERVER_ID, BSEDDIES_REVOLUTION_CHANNEL
from discordbot.embedmanager import EmbedManager
from discordbot.selects import BetSelect, BetOutcomesSelect, BetSelectAmount, TaxRateSelect

from mongo.bsedataclasses import AutoGeneratedBets, TaxRate
from mongo.bsepoints import UserPoints
from mongo.bseticketedevents import RevolutionEvent


class LeaderBoardView(discord.ui.View):
    def __init__(self, embed_manager: EmbedManager):
        self.embeds = embed_manager
        super().__init__(timeout=None)

    @discord.ui.button(
        label="Expand", 
        style=discord.ButtonStyle.primary, 
        custom_id="leaderboard_button",
        emoji="üìÑ")
    async def button_callback(self, button: discord.ui.Button, interaction: discord.Interaction):
        """
        Button Callback
        :param button:
        :param interaction:
        :return:
        """
        msg = self.embeds.get_leaderboard_embed(
            interaction.guild,
            None if button.label == "Expand" else 5
        )

        button.label = "Expand" if button.label == "Retract" else "Retract"
        await interaction.response.edit_message(view=self, content=msg)


class HighScoreBoardView(discord.ui.View):
    def __init__(self, embed_manager: EmbedManager):
        self.embeds = embed_manager
        super().__init__(timeout=None)

    @discord.ui.button(
        label="Expand", 
        style=discord.ButtonStyle.primary, 
        custom_id="highscore_button",
        emoji="üìÑ"
        )
    async def button_callback(self, button: discord.ui.Button, interaction: discord.Interaction):
        """
        Button Callback
        :param button:
        :param interaction:
        :return:
        """
        msg = self.embeds.get_highscore_embed(
            interaction.guild,
            None if button.label == "Expand" else 5
        )

        button.label = "Expand" if button.label == "Retract" else "Retract"
        await interaction.response.edit_message(view=self, content=msg)


class PlaceABetView(discord.ui.View):
    def __init__(self, bet_ids: list, user_eddies: int, submit_callback: callable):
        super().__init__(timeout=60)
        self.add_item(BetSelect(bet_ids))

        if len(bet_ids) == 1 and "option_dict" in bet_ids[0]:
            outcomes = bet_ids[0]["option_dict"]
            options = [
                discord.SelectOption(
                    label=outcomes[key]["val"],
                    value=key,
                    emoji=key
                ) for key in outcomes
            ]
        else:
            options = []

        self.add_item(BetOutcomesSelect(options))
        self.add_item(BetSelectAmount(user_eddies))

        self.submit_callback = submit_callback

    async def on_timeout(self):
        for child in self.children:
            child.disabled = True
        await self.message.edit(content="This `place` command timed out - please _place_ another one", view=None)

    @discord.ui.button(label="Submit", style=discord.ButtonStyle.green, row=3, disabled=True, emoji="üí∞")
    async def submit_callback(self, button: discord.ui.Button, interaction: discord.Interaction):

        data = {}
        for child in self.children:
            if type(child) == BetSelect:
                try:
                    data["bet_id"] = child.values[0]
                except IndexError:
                    # this means that this was default
                    data["bet_id"] = child.options[0].value
            elif type(child) == BetOutcomesSelect:
                data["emoji"] = child.values[0]
            elif type(child) == BetSelectAmount:
                data["amount"] = int(child.values[0])

        # call the callback that actually places the bet
        await self.submit_callback(
            interaction,
            data["bet_id"],
            data["amount"],
            data["emoji"]
        )

    @discord.ui.button(label="Cancel", style=discord.ButtonStyle.red, row=3, disabled=False, emoji="‚úñÔ∏è")
    async def cancel_callback(self, button: discord.ui.Button, interaction: discord.Interaction):
        await interaction.response.edit_message(content="Cancelled", view=None)


class CloseABetView(discord.ui.View):
    def __init__(self, bet_ids: list, submit_callback: callable):
        super().__init__(timeout=60)
        self.add_item(BetSelect(bet_ids))

        if len(bet_ids) == 1 and "option_dict" in bet_ids[0]:
            outcomes = bet_ids[0]["option_dict"]
            options = [
                discord.SelectOption(
                    label=outcomes[key]["val"],
                    value=key,
                    emoji=key
                ) for key in outcomes
            ]
        else:
            options = []

        self.add_item(BetOutcomesSelect(options, discord.ui.Button))
        self.submit_callback = submit_callback

    @discord.ui.button(label="Submit", style=discord.ButtonStyle.green, row=2, disabled=True)
    async def submit_callback(self, button: discord.ui.Button, interaction: discord.Interaction):

        data = {}
        for child in self.children:
            if type(child) == BetSelect:
                try:
                    data["bet_id"] = child.values[0]
                except IndexError:
                    # this means that this was default
                    data["bet_id"] = child.options[0].value
            elif type(child) == BetOutcomesSelect:
                data["emoji"] = child.values[0]

        # call the callback that actually places the bet
        await self.submit_callback(
            interaction,
            data["bet_id"],
            data["emoji"]
        )

    @discord.ui.button(label="Cancel", style=discord.ButtonStyle.red, row=2, disabled=False, emoji="‚úñÔ∏è")
    async def cancel_callback(self, button: discord.ui.Button, interaction: discord.Interaction):
        await interaction.response.edit_message(content="Cancelled", view=None)


class BetView(discord.ui.View):
    def __init__(self, bet, bseddies_place, bseddies_close):
        super().__init__(timeout=None)
        self.bet = bet
        self.place = bseddies_place
        self.close = bseddies_close

    @discord.ui.button(label="Place a bet", style=discord.ButtonStyle.blurple, emoji="üí∞")
    async def place_callback(self, button: discord.ui.Button, interaction: discord.Interaction):
        await self.place.create_bet_view(interaction, [self.bet, ])

    @discord.ui.button(label="Close this bet", style=discord.ButtonStyle.gray)
    async def close_callback(self, button: discord.ui.Button, interaction: discord.Interaction):
        await self.close.create_bet_view(interaction, [self.bet, ])


class AutoGenerateView(discord.ui.View):

    class TypeSelect(discord.ui.Select):
        def __init__(self, type_options):
            options = [
                SelectOption(label=f"{opt.title()}", value=f"{opt}") for opt in type_options
            ]

            if len(options) == 1:
                options[0].default = True

            super().__init__(
                placeholder="Select bet type",
                min_values=1,
                max_values=1,
                options=options,
                custom_id="bet_type_select"
            )

    class MethodSelect(discord.ui.Select):
        def __init__(self, method_options, auto: discord.ui.View):
            options = [
                SelectOption(
                    label=f"{opt[0].title()}",
                    value=f"{opt[0]}",
                    description=f"{opt[1]}"
                ) for opt in method_options
            ]

            self.auto = auto

            super().__init__(
                placeholder="Select generation method",
                min_values=1,
                max_values=1,
                options=options,
                custom_id="generate_method"
            )

        async def callback(self, interaction: Interaction):
            selected = interaction.data["values"][0]
            for option in self.options:
                option.default = option.value == selected

            if selected == "random":
                for child in self.auto.children:
                    if type(child) is self.auto.AutoBetsSelect:
                        self.auto.remove_item(child)
                        break
                amount_select = self.auto.BetsAmountSelect()
                self.auto.add_item(amount_select)

                for child in self.auto.children:
                    if child.custom_id == "submit_btn":
                        child.disabled = False
                        break
            else:
                type_val = ""
                for child in self.auto.children:
                    if child.custom_id == "bet_type_select":
                        try:
                            type_val = child.values[0]
                        except (IndexError, AttributeError):
                            type_val = child.options[0].value
                        continue

                    if type(child) is self.auto.BetsAmountSelect:
                        self.auto.remove_item(child)
                        continue

                auto_select = self.auto.AutoBetsSelect(type_val, self.auto)
                self.auto.add_item(auto_select)

            await interaction.response.edit_message(view=self.auto)

    class AutoBetsSelect(discord.ui.Select):
        def __init__(self, bet_type: str, auto: discord.ui.View):
            self.auto = auto
            self.auto_bets_data = AutoGeneratedBets()
            potential_bets = self.auto_bets_data.get_bets_for_type(bet_type)
            
            potential_bets = sorted(potential_bets, key=lambda b: b["title"])

            options = []
            for bet in potential_bets:
                label = f"{bet['title']}"
                if len(label) > 100:
                    label = label[:99]
                value = f"{bet['_id']}"
                options.append(SelectOption(label=label, value=value, description=bet["title"]))

            max_vals = 4
            if len(potential_bets) < max_vals:
                max_vals = len(potential_bets)

            super().__init__(
                placeholder="Select bets to create",
                min_values=1,
                max_values=max_vals,
                options=options,
                custom_id="auto_bet_select"
            )

        async def callback(self, interaction: Interaction):
            selected_vals = interaction.data["values"]
            for option in self.options:
                option.default = option.value in selected_vals

            for child in self.auto.children:
                if child.custom_id == "submit_btn":
                    child.disabled = False
                    break
            await interaction.response.edit_message(view=self.auto)

    class BetsAmountSelect(discord.ui.Select):
        def __init__(self):
            options = [
                SelectOption(label=f"{x}", value=f"{x}") for x in range(1, 6)
            ]

            options[2].default = True

            super().__init__(
                placeholder="Select number of bets to generate",
                min_values=1,
                max_values=1,
                options=options,
                custom_id="bet_amount_select"
            )

        async def callback(self, interaction: Interaction):
            selected_bet = interaction.data["values"][0]
            for option in self.options:
                option.default = option.value == selected_bet

            for child in self.view.children:
                if child.custom_id == "submit_btn":
                    child.disabled = False
                    break
            await interaction.response.edit_message(view=self.view)

    class TimeoutSelect(discord.ui.Select):
        def __init__(self):
            option_vals = ["5m", "10m", "15m", "20m", "25m", "30m", "45m", "60m"]
            options = [
                SelectOption(label=f"{x}", value=f"{x}") for x in option_vals
            ]

            options[5].default = True

            super().__init__(
                placeholder="Select bet timeout",
                min_values=1,
                max_values=1,
                options=options,
                custom_id="bet_timeout_select"
            )

        async def callback(self, interaction: Interaction):
            selected_bet = interaction.data["values"][0]
            for option in self.options:
                option.default = option.value == selected_bet
            await interaction.response.edit_message(view=self.view)
    
    def __init__(self, auto_class):
        super().__init__(timeout=120)

        generation_methods = [
            ("random", "Selects bets randomly"),
            ("selected", "Select the bets to create from the pool")
        ]

        self.auto_class = auto_class
        self.add_item(self.TypeSelect(["valorant"]))
        self.add_item(self.TimeoutSelect())
        method_select = self.MethodSelect(generation_methods, self)
        self.add_item(method_select)

    @discord.ui.button(label="Submit", style=discord.ButtonStyle.green, row=4, disabled=True, custom_id="submit_btn")
    async def submit_callback(self, button: discord.ui.Button, interaction: discord.Interaction):
        await interaction.response.defer(ephemeral=True)

        data = {"_ids": [], "number": 0, "timeout": "30m"}

        for child in self.children:
            if child.custom_id == "generate_method":
                data["method"] = child.values[0]

            elif child.custom_id == "auto_bet_select":
                data["_ids"] = child.values

            elif child.custom_id == "bet_amount_select":
                try:
                    data["number"] = child.values[0]
                except IndexError:
                    data["number"] = [opt.value for opt in child.options if opt.default is True][0]
            
            elif child.custom_id == "bet_timeout_select":
                try:
                    data["timeout"] = child.values[0]
                except IndexError:
                    data["timeout"] = [opt.value for opt in child.options if opt.default is True][0]

        await self.auto_class.autogenerate_wrapper(interaction, data["method"], data["number"], data["_ids"], data["timeout"])
        await interaction.followup.edit_message(content="Bets created", view=None, message_id=interaction.message.id)

    @discord.ui.button(label="Cancel", style=discord.ButtonStyle.red, row=4, disabled=False, custom_id="cancel_btn",
                       emoji="‚úñÔ∏è")
    async def cancel_callback(self, button: discord.ui.Button, interaction: discord.Interaction):
        await interaction.response.edit_message(content="Cancelled", view=None)


class RevolutionView(discord.ui.View):
    def __init__(self, client: discord.Client, event: dict, logger):
        super().__init__(timeout=None)
        self.client = client
        self.event_id = event["event_id"]
        self.revolutions = RevolutionEvent()
        self.user_points = UserPoints()
        self.embeds = EmbedManager(logger)
        self.logger = logger

    def toggle_stuff(self, disable):
        for child in self.children:
            child.disabled = disable

    @discord.ui.button(
        label=f"OVERTHROW",
        style=discord.ButtonStyle.green,
        custom_id="overthrow_button",
        emoji="üî•"
    )
    async def overthrow_callback(self, button: discord.ui.Button, interaction: discord.Interaction):
        response = interaction.response  # type: discord.InteractionResponse
        followup = interaction.followup  # type: discord.Webhook

        self.toggle_stuff(True)

        # disable these whilst we do revolution stuff
        await response.edit_message(view=self)

        event = self.revolutions.get_event(interaction.guild.id, self.event_id)

        if not event["open"]:
            await followup.send(content="Unfortunately, this event has expired", ephemeral=True)
            # leave it disabled
            return

        now = datetime.datetime.now()

        if event["expired"] < now:
            await followup.send(content="Unfortunately, this event has expired", ephemeral=True)
            # leave it disabled
            return

        user_id = interaction.user.id
        guild_id = interaction.guild.id

        our_user = self.user_points.find_user(
            user_id,
            guild_id,
            {"points": True, "king": True}
        )

        if our_user.get("king", False):
            await followup.send(content="You ARE the King - you can't overthrow yourself.", ephemeral=True)
            self.toggle_stuff(False)
            await followup.edit_message(interaction.message.id, view=self)
            return

        if user_id in event["supporters"]:
            await followup.send(
                content="You have already pledged to support - you can't change your mind!",
                ephemeral=True
            )
            self.toggle_stuff(False)
            await followup.edit_message(interaction.message.id, view=self)
            return

        if user_id in event["users"]:
            await followup.send(
                content="You've already acted on this - you cannot do so again",
                ephemeral=True
            )
            self.toggle_stuff(False)
            await followup.edit_message(interaction.message.id, view=self)
            return
        
        if user_id not in event["revolutionaries"]:
            event["revolutionaries"].append(user_id)

        if user_id not in event["users"]:
            event["users"].append(user_id)
            event["chance"] += 15

        self.revolutions.update(
            {"_id": event["_id"]},
            {"$set": {
                "chance": event["chance"],
                "supporters": event["supporters"],
                "revolutionaries": event["revolutionaries"],
                "users": event["users"]
            }}
        )

        self.user_points.append_to_transaction_history(
            user_id, guild_id,
            {
                "type": TransactionTypes.REV_OVERTHROW,
                "event_id": event["event_id"],
                "timestamp": datetime.datetime.now(),
            }
        )

        king = self.user_points.get_current_king(guild_id)

        king_user = await self.client.fetch_user(king["uid"])  # type: discord.User
        guild = self.client.get_guild(guild_id)

        role = guild.get_role(BSEDDIES_KING_ROLES[guild_id])

        edited_message = self.embeds.get_revolution_message(king_user, role, event)

        self.toggle_stuff(False)

        await followup.edit_message(interaction.message.id, view=self, content=edited_message)
        await followup.send(content="Congrats - you've pledged to `overthrow`!", ephemeral=True)

    @discord.ui.button(
        label=f"SUPPORT THE KING",
        style=discord.ButtonStyle.red,
        custom_id="support_button",
        emoji="üëë"
    )
    async def support_callback(self, button: discord.ui.Button, interaction: discord.Interaction):

        response = interaction.response  # type: discord.InteractionResponse
        followup = interaction.followup  # type: discord.Webhook

        self.toggle_stuff(True)

        # disable these whilst we do revolution stuff
        await response.edit_message(view=self)

        event = self.revolutions.get_event(interaction.guild.id, self.event_id)

        if not event["open"]:
            await followup.send(content="Unfortunately, this event has expired", ephemeral=True)
            # leave it disabled
            return

        now = datetime.datetime.now()

        if event["expired"] < now:
            await followup.send(content="Unfortunately, this event has expired", ephemeral=True)
            # leave it disabled
            return

        user_id = interaction.user.id
        guild_id = interaction.guild.id

        our_user = self.user_points.find_user(
            user_id,
            guild_id,
            {"points": True, "king": True}
        )

        if our_user.get("king", False):
            await followup.send(content="You ARE the King - you can't support yourself.", ephemeral=True)
            self.toggle_stuff(False)
            await followup.edit_message(interaction.message.id, view=self)
            return

        if user_id in event["revolutionaries"]:
            await followup.send(
                content="You have already pledged to overthrow - you can't change your mind!",
                ephemeral=True
            )
            self.toggle_stuff(False)
            await followup.edit_message(interaction.message.id, view=self)
            return

        if user_id in event["users"]:
            await followup.send(
                content="You've already acted on this - you cannot do so again",
                ephemeral=True
            )
            self.toggle_stuff(False)
            await followup.edit_message(interaction.message.id, view=self)
            return
        
        if user_id not in event["users"]:
            event["users"].append(user_id)
            event["chance"] -= 15
        if user_id not in event["supporters"]:
            event["supporters"].append(user_id)


        self.revolutions.update(
            {"_id": event["_id"]},
            {"$set": {
                "chance": event["chance"],
                "supporters": event["supporters"],
                "revolutionaries": event["revolutionaries"],
                "users": event["users"]
            }}
        )

        self.user_points.append_to_transaction_history(
            user_id, guild_id,
            {
                "type": TransactionTypes.REV_SUPPORT,
                "event_id": event["event_id"],
                "timestamp": datetime.datetime.now(),
            }
        )

        king = self.user_points.get_current_king(guild_id)

        king_user = await self.client.fetch_user(king["uid"])  # type: discord.User
        guild = self.client.get_guild(guild_id)

        role = guild.get_role(BSEDDIES_KING_ROLES[guild_id])

        edited_message = self.embeds.get_revolution_message(king_user, role, event)

        self.toggle_stuff(False)

        await followup.edit_message(interaction.message.id, view=self, content=edited_message)
        await followup.send(content="Congrats - you've pledged your `support`!", ephemeral=True)

    @discord.ui.button(
        label=f"Save THYSELF",
        style=discord.ButtonStyle.grey,
        custom_id="save_button",
        emoji="üíµ"
    )
    async def save_callback(self, button: discord.ui.Button, interaction: discord.Interaction):
        
        response = interaction.response  # type: discord.InteractionResponse
        followup = interaction.followup  # type: discord.Webhook

        self.toggle_stuff(True)

        # disable these whilst we do revolution stuff
        await response.edit_message(view=self)

        event = self.revolutions.get_event(interaction.guild.id, self.event_id)

        if not event["open"]:
            await followup.send(content="Unfortunately, this event has expired", ephemeral=True)
            # leave it disabled
            return

        now = datetime.datetime.now()

        if event["expired"] < now:
            await followup.send(content="Unfortunately, this event has expired", ephemeral=True)
            # leave it disabled
            return
        
        if event["king"] != interaction.user.id:
            await followup.send(content="You're not the King - so you can't use this button.")
            self.toggle_stuff(False)
            await followup.edit_message(interaction.message.id, view=self)
        
        user_id = interaction.user.id
        guild_id = interaction.guild.id

        our_user = self.user_points.find_user(
            user_id,
            guild_id,
            {"points": True, "king": True}
        )
        
        eddies = our_user["points"]
        amount_to_subtract = math.floor(eddies * 0.1)
        self.user_points.decrement_points(user_id, guild_id, amount_to_subtract)

        # add to transaction history
        self.user_points.append_to_transaction_history(
            user_id,
            guild_id,
            {
                "type": TransactionTypes.GIFT_GIVE,
                "amount": amount_to_subtract * -1,
                "timestamp": datetime.datetime.now(),
            }
        )
        
        event["chance"] -= 15
        event["times_saved"] += 1
        self.revolutions.update(
            {"_id": event["_id"]},
            {"$set": {
                "chance": event["chance"],
                "times_saved": event["times_saved"]
            }}
        )
        
        guild = self.client.get_guild(guild_id)

        role = guild.get_role(BSEDDIES_KING_ROLES[guild_id])

        edited_message = self.embeds.get_revolution_message(interaction.user, role, event)
        
        await followup.send(content=f"{interaction.user.mention} just spent `{eddies}` to reduce the overthrow chance by **15%**.")
        self.toggle_stuff(False)
        await followup.edit_message(interaction.message.id, view=self, content=edited_message)


class TaxRateView(discord.ui.View):
    def __init__(self, current_tax: float):
        super().__init__(timeout=None)
        self.select = TaxRateSelect(current_tax)
        self.add_item(self.select)
        self.tax_rate = TaxRate()
        self.user_points = UserPoints()

    def _append_to_history(self, user_id, guild_id, _type: ActivityTypes, **params):
        
        doc = {
            "type": _type,
            "timestamp": datetime.datetime.now(),
        }
        if params:
            doc["comment"] = f"Command parameters: {', '.join([f'{key}: {params[key]}' for key in params])}"
        
        doc["value"] = params["value"]
        self.user_points.append_to_activity_history(user_id, guild_id, doc)
    
    @discord.ui.button(label="Set Tax Rate", style=discord.ButtonStyle.blurple, emoji="üìà", row=2)
    async def submit_callback(self, button: discord.ui.Button, interaction: discord.Interaction):
        
        try:
            value = float(self.select.values[0])
        except (IndexError, AttributeError):
            value = float([o for o in self.select.options if o.default][0].value)
        
        self._append_to_history(
            interaction.user.id, interaction.guild.id, ActivityTypes.BSEDDIES_ACTUAL_SET_TAX_RATE, value=value
        )
        
        self.tax_rate.set_tax_rate(value)
        await interaction.response.edit_message(
            content=f"Successfully set tax rate to **{value}**.", 
            view=None
        )
        
        if interaction.guild_id == BSE_SERVER_ID:
            channel = interaction.guild.get_channel(BSEDDIES_REVOLUTION_CHANNEL)
            msg = f"{interaction.user.mention} has changed the tax rate to `{value}`! üìà"
            await channel.send(content=msg)

    @discord.ui.button(label="Cancel", style=discord.ButtonStyle.gray, emoji="‚úñÔ∏è", row=2)
    async def close_callback(self, button: discord.ui.Button, interaction: discord.Interaction):
        await interaction.response.edit_message(content="Cancelled", view=None)
