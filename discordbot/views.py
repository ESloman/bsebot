
import datetime

import discord
from discord import SelectOption, Interaction

from discordbot.bot_enums import TransactionTypes
from discordbot.constants import BSEDDIES_KING_ROLES
from discordbot.embedmanager import EmbedManager
from discordbot.selects import BetSelect, BetOutcomesSelect, BetSelectAmount

from mongo.bsedataclasses import AutoGeneratedBets
from mongo.bsepoints import UserPoints
from mongo.bseticketedevents import RevolutionEvent


class LeaderBoardView(discord.ui.View):
    def __init__(self, embed_manager: EmbedManager):
        self.embeds = embed_manager
        super().__init__(timeout=None)

    @discord.ui.button(label="Expand", style=discord.ButtonStyle.primary, custom_id="leaderboard_button")
    async def button_callback(self, button: discord.ui.Button, interaction: discord.Interaction):
        """
        Button Callback
        :param button:
        :param interaction:
        :return:
        """
        msg = self.embeds.get_leaderboard_embed(
            interaction.guild,
            None if button.label == "Expand" else 5
        )

        button.label = "Expand" if button.label == "Retract" else "Retract"
        await interaction.response.edit_message(view=self, content=msg)


class HighScoreBoardView(discord.ui.View):
    def __init__(self, embed_manager: EmbedManager):
        self.embeds = embed_manager
        super().__init__(timeout=None)

    @discord.ui.button(label="Expand", style=discord.ButtonStyle.primary, custom_id="highscore_button")
    async def button_callback(self, button: discord.ui.Button, interaction: discord.Interaction):
        """
        Button Callback
        :param button:
        :param interaction:
        :return:
        """
        msg = self.embeds.get_highscore_embed(
            interaction.guild,
            None if button.label == "Expand" else 5
        )

        button.label = "Expand" if button.label == "Retract" else "Retract"
        await interaction.response.edit_message(view=self, content=msg)


class PlaceABetView(discord.ui.View):
    def __init__(self, bet_ids: list, user_eddies: int, submit_callback: callable):
        super().__init__(timeout=60)
        self.add_item(BetSelect(bet_ids))

        if len(bet_ids) == 1 and "option_dict" in bet_ids[0]:
            outcomes = bet_ids[0]["option_dict"]
            options = [
                discord.SelectOption(
                    label=outcomes[key]["val"],
                    value=key,
                    emoji=key
                ) for key in outcomes
            ]
        else:
            options = []

        self.add_item(BetOutcomesSelect(options))
        self.add_item(BetSelectAmount(user_eddies))

        self.submit_callback = submit_callback

    async def on_timeout(self):
        for child in self.children:
            child.disabled = True
        await self.message.edit(content="This `place` command timed out - please _place_ another one", view=None)

    @discord.ui.button(label="Submit", style=discord.ButtonStyle.green, row=3, disabled=True, custom_id="submit_btn")
    async def submit_callback(self, button: discord.ui.Button, interaction: discord.Interaction):

        data = {}
        for child in self.children:
            if child.custom_id == "bet_select":
                try:
                    data["bet_id"] = child.values[0]
                except IndexError:
                    # this means that this was default
                    data["bet_id"] = child.options[0].value
            elif child.custom_id == "outcome_select":
                data["emoji"] = child.values[0]
            elif child.custom_id == "amount_select":
                data["amount"] = int(child.values[0])

        # call the callback that actually places the bet
        await self.submit_callback(
            interaction,
            data["bet_id"],
            data["amount"],
            data["emoji"]
        )

    @discord.ui.button(label="Cancel", style=discord.ButtonStyle.red, row=3, disabled=False, custom_id="cancel_btn")
    async def cancel_callback(self, button: discord.ui.Button, interaction: discord.Interaction):
        await interaction.response.edit_message(content="Cancelled", view=None)


class CloseABetView(discord.ui.View):
    def __init__(self, bet_ids: list, submit_callback: callable):
        super().__init__(timeout=60)
        self.add_item(BetSelect(bet_ids))

        if len(bet_ids) == 1 and "option_dict" in bet_ids[0]:
            outcomes = bet_ids[0]["option_dict"]
            options = [
                discord.SelectOption(
                    label=outcomes[key]["val"],
                    value=key,
                    emoji=key
                ) for key in outcomes
            ]
        else:
            options = []

        self.add_item(BetOutcomesSelect(options, "submit_btn"))
        self.submit_callback = submit_callback

    @discord.ui.button(label="Submit", style=discord.ButtonStyle.green, row=2, disabled=True, custom_id="submit_btn")
    async def submit_callback(self, button: discord.ui.Button, interaction: discord.Interaction):

        data = {}
        for child in self.children:
            if child.custom_id == "bet_select":
                try:
                    data["bet_id"] = child.values[0]
                except IndexError:
                    # this means that this was default
                    data["bet_id"] = child.options[0].value
            elif child.custom_id == "outcome_select":
                data["emoji"] = child.values[0]

        # call the callback that actually places the bet
        await self.submit_callback(
            interaction,
            data["bet_id"],
            data["emoji"]
        )

    @discord.ui.button(label="Cancel", style=discord.ButtonStyle.red, row=2, disabled=False, custom_id="cancel_btn")
    async def cancel_callback(self, button: discord.ui.Button, interaction: discord.Interaction):
        await interaction.response.edit_message(content="Cancelled", view=None)


class BetView(discord.ui.View):
    def __init__(self, bet, bseddies_place, bseddies_close):
        super().__init__(timeout=None)
        self.bet = bet
        self.place = bseddies_place
        self.close = bseddies_close

    @discord.ui.button(label="Place a bet", style=discord.ButtonStyle.blurple)
    async def place_callback(self, button: discord.ui.Button, interaction: discord.Interaction):
        await self.place.create_bet_view(interaction, [self.bet, ])

    @discord.ui.button(label="Close this bet", style=discord.ButtonStyle.gray)
    async def close_callback(self, button: discord.ui.Button, interaction: discord.Interaction):
        await self.close.create_bet_view(interaction, [self.bet, ])


class AutoGenerateView(discord.ui.View):

    class TypeSelect(discord.ui.Select):
        def __init__(self, type_options):
            options = [
                SelectOption(label=f"{opt.title()}", value=f"{opt}") for opt in type_options
            ]

            if len(options) == 1:
                options[0].default = True

            super().__init__(
                placeholder="Select bet type",
                min_values=1,
                max_values=1,
                options=options,
                custom_id="bet_type_select"
            )

    class MethodSelect(discord.ui.Select):
        def __init__(self, method_options, auto: discord.ui.View):
            options = [
                SelectOption(
                    label=f"{opt[0].title()}",
                    value=f"{opt[0]}",
                    description=f"{opt[1]}"
                ) for opt in method_options
            ]

            self.auto = auto

            super().__init__(
                placeholder="Select generation method",
                min_values=1,
                max_values=1,
                options=options,
                custom_id="generate_method"
            )

        async def callback(self, interaction: Interaction):
            selected = interaction.data["values"][0]
            for option in self.options:
                option.default = option.value == selected

            if selected == "random":
                for child in self.auto.children:
                    if type(child) is self.auto.AutoBetsSelect:
                        self.auto.remove_item(child)
                        break
                amount_select = self.auto.BetsAmountSelect(self.auto)
                self.auto.add_item(amount_select)

                for child in self.auto.children:
                    if child.custom_id == "submit_btn":
                        child.disabled = False
                        break
            else:
                type_val = ""
                for child in self.auto.children:
                    if child.custom_id == "bet_type_select":
                        try:
                            type_val = child.values[0]
                        except (IndexError, AttributeError):
                            type_val = child.options[0].value
                        continue

                    if type(child) is self.auto.BetsAmountSelect:
                        self.auto.remove_item(child)
                        continue

                auto_select = self.auto.AutoBetsSelect(type_val, self.auto)
                self.auto.add_item(auto_select)

            await interaction.response.edit_message(view=self.auto)

    class AutoBetsSelect(discord.ui.Select):
        def __init__(self, bet_type: str, auto: discord.ui.View):
            self.auto = auto
            self.auto_bets_data = AutoGeneratedBets()
            potential_bets = self.auto_bets_data.get_bets_for_type(bet_type)

            options = []
            for bet in potential_bets:
                label = f"{bet['title']}"
                if len(label) > 100:
                    label = label[:99]
                value = f"{bet['_id']}"
                options.append(SelectOption(label=label, value=value, description=bet["title"]))

            max_vals = 4
            if len(potential_bets) < max_vals:
                max_vals = len(potential_bets)

            super().__init__(
                placeholder="Select bets to create",
                min_values=1,
                max_values=max_vals,
                options=options,
                custom_id="auto_bet_select"
            )

        async def callback(self, interaction: Interaction):
            selected_vals = interaction.data["values"]
            for option in self.options:
                option.default = option.value in selected_vals

            for child in self.auto.children:
                if child.custom_id == "submit_btn":
                    child.disabled = False
                    break
            await interaction.response.edit_message(view=self.auto)

    class BetsAmountSelect(discord.ui.Select):
        def __init__(self, auto: discord.ui.View):
            options = [
                SelectOption(label=f"{x}", value=f"{x}") for x in range(1, 6)
            ]

            options[2].default = True

            self.auto = auto

            super().__init__(
                placeholder="Select number of bets to generate",
                min_values=1,
                max_values=1,
                options=options,
                custom_id="bet_amount_select"
            )

        async def callback(self, interaction: Interaction):
            selected_bet = interaction.data["values"][0]
            for option in self.options:
                option.default = option.value == selected_bet

            for child in self.auto.children:
                if child.custom_id == "submit_btn":
                    child.disabled = False
                    break
            await interaction.response.edit_message(view=self.auto)

    def __init__(self):
        super().__init__(timeout=120)

        generation_methods = [
            ("random", "Selects bets randomly"),
            ("selected", "Select the bets to create from the pool")
        ]

        self.add_item(self.TypeSelect(["valorant"]))
        method_select = self.MethodSelect(generation_methods, self)
        self.add_item(method_select)

    @discord.ui.button(label="Submit", style=discord.ButtonStyle.green, row=4, disabled=True, custom_id="submit_btn")
    async def submit_callback(self, button: discord.ui.Button, interaction: discord.Interaction):
        await interaction.response.defer()

        data = {}
        for child in self.children:
            if child.custom_id == "generate_method":
                data["method"] = child.values[0]

            elif child.custom_id == "auto_bet_select":
                data["_ids"] = child.values

            elif child.custom_id == "bet_amount_select":
                try:
                    data["number"] = child.values[0]
                except IndexError:
                    data["number"] = [opt.value for opt in child.options if opt.default is True][0]

        print(data)

    @discord.ui.button(label="Cancel", style=discord.ButtonStyle.red, row=4, disabled=False, custom_id="cancel_btn")
    async def cancel_callback(self, button: discord.ui.Button, interaction: discord.Interaction):
        await interaction.response.edit_message(content="Cancelled", view=None)


class RevolutionView(discord.ui.View):
    def __init__(self, client: discord.Client, event: dict, logger):
        super().__init__(timeout=None)
        self.client = client
        self.event_id = event["event_id"]
        self.revolutions = RevolutionEvent()
        self.user_points = UserPoints()
        self.embeds = EmbedManager(logger)
        self.logger = logger

    def toggle_stuff(self, disable):
        for child in self.children:
            child.disabled = disable

    @discord.ui.button(
        label=f"OVERTHROW",
        style=discord.ButtonStyle.green,
        custom_id="overthrow_button",
        emoji=":flame:"
    )
    async def overthrow_callback(self, button: discord.ui.Button, interaction: discord.Interaction):
        response = interaction.response  # type: discord.InteractionResponse
        followup = interaction.followup  # type: discord.Webhook

        self.toggle_stuff(True)

        # disable these whilst we do revolution stuff
        await response.edit_message(view=self)

        event = self.revolutions.get_event(interaction.guild.id, self.event_id)

        if not event["open"]:
            await followup.send(content="Unfortunately, this event has expired", ephemeral=True)
            # leave it disabled
            return

        now = datetime.datetime.now()

        if event["expired"] < now:
            await followup.send(content="Unfortunately, this event has expired", ephemeral=True)
            # leave it disabled
            return

        user_id = interaction.user.id
        guild_id = interaction.guild.id

        our_user = self.user_points.find_user(
            user_id,
            guild_id,
            {"points": True, "king": True}
        )

        if our_user.get("king", False):
            await followup.send(content="You ARE the King - you can't overthrow yourself.", ephemeral=True)
            self.toggle_stuff(False)
            await followup.edit_message(interaction.message.id, view=self)
            return

        if user_id in event["supporters"]:
            await followup.send(
                content="You have already pledged to support - you can't change your mind!",
                ephemeral=True
            )
            self.toggle_stuff(False)
            await followup.edit_message(interaction.message.id, view=self)
            return

        event["chance"] += 15

        if user_id not in event["revolutionaries"]:
            event["revolutionaries"].append(user_id)

        if user_id not in event["users"]:
            event["users"].append(user_id)

        if user_id in event["supporters"]:
            event["chance"] += 15
            event["supporters"].pop(user_id)

        self.revolutions.update(
            {"_id": event["_id"]},
            {"$set": {
                "chance": event["chance"],
                "supporters": event["supporters"],
                "revolutionaries": event["revolutionaries"],
                "users": event["users"]
            }}
        )

        self.user_points.append_to_transaction_history(
            user_id, guild_id,
            {
                "type": TransactionTypes.REV_OVERTHROW,
                "event_id": event["event_id"],
                "timestamp": datetime.datetime.now(),
            }
        )

        king = self.user_points.get_current_king(guild_id)

        king_user = await self.client.fetch_user(king["uid"])  # type: discord.User
        guild = self.client.get_guild(guild_id)

        role = guild.get_role(BSEDDIES_KING_ROLES[guild_id])

        edited_message = self.embeds.get_revolution_message(king_user, role, event)

        self.toggle_stuff(False)

        await followup.edit_message(interaction.message.id, view=self, content=edited_message)
        await followup.send(content="Congrats - you've pledged to `overthrow`!", ephemeral=True)

    @discord.ui.button(
        label=f"SUPPORT THE KING",
        style=discord.ButtonStyle.red,
        custom_id="support_button",
        emoji=":crown:"
    )
    async def support_callback(self, button: discord.ui.Button, interaction: discord.Interaction):

        response = interaction.response  # type: discord.InteractionResponse
        followup = interaction.followup  # type: discord.Webhook

        self.toggle_stuff(True)

        # disable these whilst we do revolution stuff
        await response.edit_message(view=self)

        event = self.revolutions.get_event(interaction.guild.id, self.event_id)

        if not event["open"]:
            await followup.send(content="Unfortunately, this event has expired", ephemeral=True)
            # leave it disabled
            return

        now = datetime.datetime.now()

        if event["expired"] < now:
            await followup.send(content="Unfortunately, this event has expired", ephemeral=True)
            # leave it disabled
            return

        user_id = interaction.user.id
        guild_id = interaction.guild.id

        our_user = self.user_points.find_user(
            user_id,
            guild_id,
            {"points": True, "king": True}
        )

        if our_user.get("king", False):
            await followup.send(content="You ARE the King - you can't support yourself.", ephemeral=True)
            self.toggle_stuff(False)
            await followup.edit_message(interaction.message.id, view=self)
            return

        if user_id in event["revolutionaries"]:
            await followup.send(
                content="You have already pledged to overthrow - you can't change your mind!",
                ephemeral=True
            )
            self.toggle_stuff(False)
            await followup.edit_message(interaction.message.id, view=self)
            return

        event["chance"] -= 15

        if user_id not in event["supporters"]:
            event["supporters"].append(user_id)
        if user_id not in event["users"]:
            event["users"].append(user_id)

        self.revolutions.update(
            {"_id": event["_id"]},
            {"$set": {
                "chance": event["chance"],
                "supporters": event["supporters"],
                "revolutionaries": event["revolutionaries"],
                "users": event["users"]
            }}
        )

        self.user_points.append_to_transaction_history(
            user_id, guild_id,
            {
                "type": TransactionTypes.REV_SUPPORT,
                "event_id": event["event_id"],
                "timestamp": datetime.datetime.now(),
            }
        )

        king = self.user_points.get_current_king(guild_id)

        king_user = await self.client.fetch_user(king["uid"])  # type: discord.User
        guild = self.client.get_guild(guild_id)

        role = guild.get_role(BSEDDIES_KING_ROLES[guild_id])

        edited_message = self.embeds.get_revolution_message(king_user, role, event)

        self.toggle_stuff(False)

        await followup.edit_message(interaction.message.id, view=self, content=edited_message)
        await followup.send(content="Congrats - you've pledged your `support`!", ephemeral=True)
