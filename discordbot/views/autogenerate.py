"""Autogenerate view."""

from typing import TYPE_CHECKING

import discord

from discordbot.selects.autogenerate import (
    AutoBetsSelect,
    BetsAmountSelect,
    ChannelSelect,
    MethodSelect,
    TimeoutSelect,
    TypeSelect,
)
from discordbot.views.bseview import BSEView
from mongo.bsedataclasses import AutoGeneratedBets

if TYPE_CHECKING:
    from discordbot.slashcommandeventclasses.autogenerate import AutoGenerate


class AutoGenerateView(BSEView):
    """Class for Autogenerate view."""

    def __init__(self, auto_class: object) -> None:
        """Initialisation method.

        Args:
            auto_class (AutoGenerate): the actual class for handling autogenerate stuff
        """
        super().__init__(timeout=120)
        self.auto_bets = AutoGeneratedBets()

        generation_methods = [
            ("random", "Selects bets randomly"),
            ("selected", "Select the bets to create from the pool"),
        ]

        self.selected_type = None
        self.current_page = 1
        self.data = {"_ids": [], "timeout": "30m"}
        self.auto_class: AutoGenerate = auto_class

        categories: list[str] = [cat.lower() for cat in self.auto_bets.get_bet_categories() if cat != "pook"]

        self.type_select = TypeSelect(categories)
        self.timeout_select = TimeoutSelect()
        self.channel_select = ChannelSelect()
        self.method_select = MethodSelect(generation_methods)
        self.amount_select = None
        self.bets_select = None

        self.add_item(self.type_select)
        self.add_item(self.timeout_select)
        self.add_item(self.channel_select)

    def _update_first_page(self) -> None:
        """Updates the data on the first page."""
        channel = self.data.get("channel")
        auto_type = self.data.get("type")
        timeout = self.data.get("timeout")

        if not timeout:
            timeout = self.get_select_value(self.timeout_select)
            if timeout:
                self.data["timeout"] = timeout

        if channel and auto_type and timeout:
            self.toggle_button(False, "Next")

    def _update_second_page(self) -> None:
        """Updates the data on the second page."""
        method = self.data.get("method")
        if method == "random" and not self.amount_select:
            if self.bets_select:
                self.remove_item(self.bets_select)
                self.bets_select = None

            self.amount_select = BetsAmountSelect()
            self.add_item(self.amount_select)
            self.toggle_button(True, "Submit")

        elif method == "selected" and not self.bets_select:
            if self.amount_select:
                self.remove_item(self.amount_select)
                self.amount_select = None

            self.bets_select = AutoBetsSelect(self.data["type"])
            self.add_item(self.bets_select)
            self.toggle_button(True, "Submit")

        elif method == "random":
            number = self.data.get("number")
            if number:
                self.toggle_button(False, "Submit")

        elif method == "selected":
            bet_ids = self.data.get("_ids")
            if bet_ids:
                self.toggle_button(False, "Submit")

    async def update(self, interaction: discord.Interaction) -> None:
        """View update method.

        Can be called by child types when something changes.

        Args:
            interaction (discord.Interaction): _description_
        """
        if self.current_page == 1:
            self._update_first_page()

        elif self.current_page == 2:  # noqa: PLR2004
            self._update_second_page()

        await interaction.response.edit_message(content=interaction.message.content, view=self)

    @discord.ui.button(label="Next", style=discord.ButtonStyle.green, row=4, disabled=True, custom_id="submit_btn")
    async def submit_callback(self, _: discord.ui.Button, interaction: discord.Interaction) -> None:
        """Button callback.

        Args:
            _ (discord.ui.Button): the button pressed
            interaction (discord.Interaction): the callback interaction
        """
        await interaction.response.defer(ephemeral=True)

        if self.current_page == 1:
            # first page; let's go to page 2
            for child in self.children:
                if child.custom_id == "submit_btn":
                    child.label = "Submit"
                    child.disabled = True
                    break

            self.remove_item(self.type_select)
            self.remove_item(self.timeout_select)
            self.remove_item(self.channel_select)

            # add the next stuff
            self.add_item(self.method_select)
            await interaction.followup.edit_message(
                content=interaction.message.content,
                view=self,
                message_id=interaction.message.id,
            )
            self.current_page += 1
            return

        await self.auto_class.autogenerate_wrapper(
            interaction,
            self.data.get("type"),
            self.data.get("method"),
            self.data.get("number"),
            self.data.get("_ids"),
            self.data.get("timeout"),
            self.data.get("channel"),
        )
        await interaction.followup.edit_message(content="Bets created", view=None, message_id=interaction.message.id)

    @staticmethod
    @discord.ui.button(
        label="Cancel",
        style=discord.ButtonStyle.red,
        row=4,
        disabled=False,
        emoji="✖️",
    )
    async def cancel_callback(_: discord.ui.Button, interaction: discord.Interaction) -> None:
        """Button callback.

        Args:
            _ (discord.ui.Button): the button pressed
            interaction (discord.Interaction): the callback interaction
        """
        await interaction.response.edit_message(content="Cancelled", view=None, delete_after=2)
