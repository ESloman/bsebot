"""This is a file for Collection Classes in a MongoDB database.

A MongoDB database can have lots of Collections (basically tables). Each Collection should have a class here
that provides methods for interacting with that Collection.

This particular file contains Collection Classes for the 'bestsummereverpoints' DB.
"""

import datetime
import random

from bson import ObjectId
from pymongo.results import InsertOneResult

from discordbot.bot_enums import AwardsTypes, StatTypes
from discordbot.stats.statsdataclasses import Stat
from discordbot.wordle.data_type import WordleSolve
from mongo import interface
from mongo.datatypes.thread import ThreadDB
from mongo.db_classes import BestSummerEverPointsDB


class AutoGeneratedBets(BestSummerEverPointsDB):
    """Class for interacting with the 'autogeneratedbets' MongoDB collection in the 'bestsummereverpoints' DB."""

    def __init__(self) -> None:
        """Constructor method that initialises the vault object."""
        super().__init__()
        self._vault = interface.get_collection(self.database, "autogeneratedbets")

    def insert_generated_bet(self, scenario_type: str, title: str, options: list[str]) -> None:
        """Insert a bet into the DB that we can pull out later.

        Args:
            scenario_type (str): _description_
            title (str): _description_
            options (list): _description_
        """
        document = {"type": scenario_type, "title": title, "options": options}

        if not options:
            document["voice_channel"] = True

        self.insert(document)

    def insert_new_category(self, category: str) -> None:
        """Inserts a dummy entry to add a new category.

        Args:
            category (str): the new category name
        """
        document = {"type": category, "selectable": False}
        self.insert(document)

    def get_all_bets(self) -> list[dict[str, any]]:
        """_summary_.

        Returns:
            list: _description_
        """
        rets = self.query({"selectable": {"$ne": False}})
        return [r for r in rets if not r.get("archived")]

    def get_bet_categories(self) -> list[str]:
        """_summary_.

        Returns:
            list: _description_
        """
        return self.vault.distinct("type", {"archived": {"$ne": True}})

    def get_bets_for_type(self, scenario_type: str) -> list[dict[str, any]]:
        """Gets ALL bets for a specified type.

        :param scenario_type:
        :return:
        """
        return self.query({"type": scenario_type, "selectable": {"$ne": False}})

    def get_random_bets_for_type(self, scenario_type: str, amount: int = 3) -> list[dict[str, any]]:
        """Gets a random sample of bets for a specified type.

        :param scenario_type:
        :param amount:
        :return:
        """
        rets = self.get_bets_for_type(scenario_type)
        try:
            return random.sample(rets, int(amount))
        except ValueError:
            return rets


class SpoilerThreads(BestSummerEverPointsDB):
    """Class for interacting with the 'autogeneratedbets' MongoDB collection in the 'bestsummereverpoints' DB."""

    def __init__(self) -> None:
        """Constructor method that initialises the vault object."""
        super().__init__()
        self._vault = interface.get_collection(self.database, "spoilerthreads")

    def get_all_threads(self, guild_id: int) -> list[ThreadDB]:
        """Gets all threads from the DB.

        Args:
            guild_id (int): the guild to get the threads for

        Returns:
            list: list of Threads
        """
        ret = self.query({"guild_id": guild_id})
        return [ThreadDB(**thread) for thread in ret]

    def insert_spoiler_thread(  # noqa: PLR0913, PLR0917
        self,
        guild_id: int,
        thread_id: int,
        name: str,
        created: datetime.datetime,
        owner: int,
        new_episode_day: int | None = None,
    ) -> list[ObjectId]:
        """Insert a bet into the DB that we can pull out later.

        :return:
        """
        document = {
            "guild_id": guild_id,
            "thread_id": thread_id,
            "name": name,
            "day": new_episode_day,
            "active": True,
            "created": created,
            "owner": owner,
        }

        return self.insert(document)

    def get_thread_by_id(self, guild_id: int, thread_id: int) -> None | ThreadDB:
        """Gets a database thread by ID.

        Args:
            guild_id (int): _description_
            thread_id (int): _description_

        Returns:
            None | Thread: _description_
        """
        ret = self.query({"guild_id": guild_id, "thread_id": thread_id})
        if ret:
            return ThreadDB(**ret[0])
        return None


class Awards(BestSummerEverPointsDB):
    """Class for interacting with the 'awards' MongoDB collection in the 'bestsummereverpoints' DB."""

    def __init__(self) -> None:
        """Initialisation method."""
        super().__init__()
        self._vault = interface.get_collection(self.database, "awards")

    def document_stat(  # noqa: PLR0913, PLR0917
        self,
        guild_id: int,
        stat: StatTypes,
        value: (float | (datetime.datetime | datetime.date)),
        timestamp: datetime.datetime,
        short_name: str,
        annual: bool,
        month: str | None = None,
        year: str | None = None,
        dry_run: bool = False,
        **kwargs: dict[str, any],
    ) -> list[ObjectId]:
        """Inserts a stat into the database.

        Args:
            guild_id (int): _description_
            stat (StatTypes): _description_
            value (float  |): _description_
            timestamp (datetime.datetime): _description_
            short_name (str): _description_
            annual (bool): _description_
            month (str | None, optional): _description_. Defaults to None.
            year (str | None, optional): _description_. Defaults to None.
            dry_run (bool, optional): _description_. Defaults to False.

        Returns:
            list: _description_
        """
        if type(value) is datetime.date:
            # convert date into something MongoDB wants to parse
            value = value.strftime("%Y-%m-%d")

        doc = {
            "type": "stat",
            "guild_id": guild_id,
            "stat": stat,
            "timestamp": timestamp,
            "month": month,
            "value": value,
            "short_name": short_name,
            "annual": annual,
            "year": year,
        }

        for key in kwargs:
            if key not in doc:
                doc[key] = kwargs[key]

        if not dry_run:
            return self.insert(doc)
        return None

    def document_award(  # noqa: PLR0913, PLR0917
        self,
        guild_id: int,
        user_id: int,
        award: AwardsTypes,
        eddies: int,
        value: float,
        short_name: str,
        annual: bool,
        month: str | None = None,
        year: str | None = None,
        dry_run: bool = False,
        **kwargs: dict[str, any],
    ) -> list[ObjectId]:
        """Insert an award into the DB.

        Args:
            guild_id (int): server ID
            user_id (int): user ID
            award (AwardsTypes): the enum type of the award won
            month (str): a readable format like 'Oct 22'
            eddies (int): the eddies won
            value (float): _description_
            short_name (str): _description_
            annual (bool): _description_
            month (str | None, optional): _description_. Defaults to None.
            year (str | None, optional): _description_. Defaults to None.
            dry_run (bool, optional): _description_. Defaults to False.

        Returns:
            list: _description_
        """
        doc = {
            "type": "award",
            "guild_id": guild_id,
            "user_id": user_id,
            "award": award,
            "timestamp": datetime.datetime.now(),
            "month": month,
            "eddies": eddies,
            "value": value,
            "short_name": short_name,
            "annual": annual,
            "year": year,
        }

        for key in kwargs:
            if key not in doc:
                doc[key] = kwargs[key]

        if not dry_run:
            return self.insert(doc)
        return None

    def find_entry(self, award_or_stat: Stat) -> list[dict[str, any]]:
        """Finds an award or stat in the database.

        Builds a query for the given award/stat and returns anything it finds.

        Args:
            award_or_stat (Stat): the award or stat to search

        Returns:
            list: the found entry(ies)
        """
        query = {
            "type": award_or_stat.type,
            "guild_id": award_or_stat.guild_id,
            "value": award_or_stat.value,
            "annual": award_or_stat.annual,
            "user_id": award_or_stat.user_id,
            "short_name": award_or_stat.short_name,
        }

        if award_or_stat.annual:
            query["year"] = award_or_stat.year
        else:
            query["month"] = award_or_stat.month

        match award_or_stat.type:
            case "award":
                query["award"] = award_or_stat.award
            case "stat":
                query["stat"] = award_or_stat.stat

        return self.query(query)


class WordleAttempts(BestSummerEverPointsDB):
    """Class for interacting with the 'awards' MongoDB collection in the 'bestsummereverpoints' DB."""

    def __init__(self) -> None:
        """Initialiation method."""
        super().__init__()
        self._vault = interface.get_collection(self.database, "wordles")

    def document_wordle(self, guild_id: int, wordle_solve: WordleSolve) -> list[ObjectId]:
        """Inserts a wordle entry into the database.

        Args:
            guild_id (int): _description_
            wordle_solve (WordleSolve): _description_

        Returns:
            list: _description_
        """
        doc = {k: v for k, v in wordle_solve.__dict__.items() if v is not None}

        doc["game_state"] = {str(k): v for k, v in doc["game_state"].items()}

        doc["guild_id"] = guild_id
        doc["timestamp"] = doc["timestamp"].strftime("%Y-%m-%d")

        return self.insert(doc)


class BotActivities(BestSummerEverPointsDB):
    """Class for interacting with the 'botactivities' MongoDB collection in the 'bestsummereverpoints' DB."""

    def __init__(self) -> None:
        """Constructor method that initialises the vault object."""
        super().__init__()
        self._vault = interface.get_collection(self.database, "botactivities")

    def insert_activity(self, category: str, name: str, created_by: int) -> InsertOneResult:
        """Inserts a new bot activity into the database.

        Args:
            category (str): the category - either: listening, watching, playing
            name (str): the activity name
            created_by (int): which user created it

        Returns:
            InsertOneResult: insert result
        """
        doc = {
            "category": category,
            "name": name,
            "created_by": created_by,
            "created": datetime.datetime.now(),
            "count": 0,
            "archived": False,
        }

        return self.insert(doc)

    def find_activity(self, name: str, activity: str) -> dict[str, any]:
        """Find an existing activity.

        Args:
            name (str): name fo the activity
            activity (str): the category

        Returns:
            dict: _description_
        """
        ret = self.query({"category": activity, "name": name})
        return ret[0] if ret else None

    def get_all_activities(self) -> list[dict[str, any]]:
        """Returns all activities from the collection.

        Returns:
            list: _description_
        """
        return self.query({"archived": False})


class WordleReminders(BestSummerEverPointsDB):
    """Class for interacting with the 'wordlereminders' MongoDB collection in the 'bestsummereverpoints' DB."""

    def __init__(self) -> None:
        """Constructor method that initialises the vault object."""
        super().__init__()
        self._vault = interface.get_collection(self.database, "wordlereminders")

    def insert_reminder(self, name: str, created_by: int) -> InsertOneResult:
        """Inserts a new wordle reminder into the database.

        Args:
            name (str): the reminder name
            created_by (int): which user created it

        Returns:
            InsertOneResult: insert result
        """
        doc = {
            "name": name,
            "created_by": created_by,
            "created": datetime.datetime.now(),
            "archived": False,
        }

        return self.insert(doc)

    def get_all_reminders(self) -> list[dict[str, any]]:
        """Returns all reminders from the collection.

        Returns:
            list: _description_
        """
        return self.query({"archived": False})
