"""Contains various interfaces for collections of different data in the database."""

import dataclasses
import datetime
import random

import pytz
from bson import ObjectId

from discordbot.bot_enums import AwardsTypes, StatTypes
from discordbot.stats.statsdataclasses import StatDB
from discordbot.wordle.data_type import WordleSolve
from mongo.baseclass import BaseClass
from mongo.datatypes.autogeneratedbets import AutoGeneratedBetDB
from mongo.datatypes.botactivities import BotActivityDB
from mongo.datatypes.thread import ThreadDB
from mongo.datatypes.wordle import WordleAttemptDB, WordleReminderDB


class AutoGeneratedBets(BaseClass):
    """Class for interacting with the 'autogeneratedbets' MongoDB collection in the 'bestsummereverpoints' DB."""

    def __init__(self) -> None:
        """Constructor method that initialises the vault object."""
        super().__init__(collection="autogeneratedbets")

    @staticmethod
    def make_data_class(data: dict[str, any]) -> AutoGeneratedBetDB:
        """Converts the data into an AutoGeneratedBetDB.

        Args:
            data (dict[str, any]): data to convert

        Returns:
            AutoGeneratedBetDB: the dataclass
        """
        return AutoGeneratedBetDB(**data)

    def insert_generated_bet(self, scenario_type: str, title: str, options: list[str]) -> AutoGeneratedBetDB:
        """Insert a bet into the DB that we can pull out later.

        Args:
            scenario_type (str): the bet type
            title (str): the bet title
            options (list[str]): the list of bet options. Can be empty.

        Returns:
            AutoGeneratedBetDB: the created bet class
        """
        document = {"type": scenario_type, "title": title, "options": options}

        if not options:
            document["voice_channel"] = True

        _id = self.insert(document)[0]
        document["_id"] = _id
        return self.make_data_class(document)

    def insert_new_category(self, category: str) -> None:
        """Inserts a dummy entry to add a new category.

        Args:
            category (str): the new category name
        """
        document = {"type": category, "selectable": False}
        self.insert(document)

    def get_all_bets(self) -> list[AutoGeneratedBetDB]:
        """Gets all the bets in the database.

        Returns:
            list: the list of all autogenerated bets
        """
        rets: list[AutoGeneratedBetDB] = self.query({"selectable": {"$ne": False}})
        return [r for r in rets if not r.archived]

    def get_bet_categories(self) -> list[str]:
        """Gets all the bet categories in the database.

        Returns:
            list: the list of bet categories
        """
        return self.vault.distinct("type", {"archived": {"$ne": True}})

    def get_bets_for_type(self, scenario_type: str) -> list[AutoGeneratedBetDB]:
        """Gets ALL bets for a specified type.

        :param scenario_type:
        :return:
        """
        return self.query({"type": scenario_type, "selectable": {"$ne": False}})

    def get_random_bets_for_type(self, scenario_type: str, amount: int = 3) -> list[AutoGeneratedBetDB]:
        """Gets a random sample of bets for a specified type.

        :param scenario_type:
        :param amount:
        :return:
        """
        rets: list[AutoGeneratedBetDB] = self.get_bets_for_type(scenario_type)
        try:
            return random.sample(rets, int(amount))
        except ValueError:
            return rets


class SpoilerThreads(BaseClass):
    """Class for interacting with the 'autogeneratedbets' MongoDB collection in the 'bestsummereverpoints' DB."""

    def __init__(self) -> None:
        """Constructor method that initialises the vault object."""
        super().__init__(collection="spoilerthreads")

    @staticmethod
    def make_data_class(data: dict[str, any]) -> ThreadDB:
        """Converts the data into an ThreadDB.

        Args:
            data (dict[str, any]): data to convert

        Returns:
            ThreadDB: the dataclass
        """
        return ThreadDB(**data)

    def get_all_threads(self, guild_id: int) -> list[ThreadDB]:
        """Gets all threads from the DB.

        Args:
            guild_id (int): the guild to get the threads for

        Returns:
            list: list of Threads
        """
        return self.query({"guild_id": guild_id})

    def insert_spoiler_thread(  # noqa: PLR0913
        self,
        guild_id: int,
        thread_id: int,
        name: str,
        created: datetime.datetime,
        owner: int,
        new_episode_day: int | None = None,
    ) -> ThreadDB:
        """Insert a bet into the DB that we can pull out later.

        :return:
        """
        document = {
            "guild_id": guild_id,
            "thread_id": thread_id,
            "name": name,
            "day": new_episode_day,
            "active": True,
            "created": created,
            "owner": owner,
        }
        _id = self.insert(document)[0]
        document["_id"] = _id
        return self.make_data_class(document)

    def get_thread_by_id(self, guild_id: int, thread_id: int) -> None | ThreadDB:
        """Gets a database thread by ID.

        Args:
            guild_id (int): _description_
            thread_id (int): _description_

        Returns:
            None | Thread: _description_
        """
        ret: list[ThreadDB] = self.query({"guild_id": guild_id, "thread_id": thread_id})
        if ret:
            return ret[0]
        return None


class Awards(BaseClass):
    """Class for interacting with the 'awards' MongoDB collection in the 'bestsummereverpoints' DB."""

    def __init__(self) -> None:
        """Initialisation method."""
        super().__init__(collection="awards")

    @staticmethod
    def make_data_class(data: dict[str, any]) -> StatDB:
        """Convert data to dataclass.

        Args:
            data (dict[str, any]): the data to convert

        Returns:
            Stat: the dataclass
        """
        cls_fields = {f.name for f in dataclasses.fields(StatDB)}
        extras = {k: v for k, v in data.items() if k not in cls_fields}
        fields = {k: v for k, v in data.items() if k in cls_fields}
        if kwargs := fields.get("kwargs"):
            kwargs.update(extras)
        else:
            fields["kwargs"] = extras
        return StatDB(**{k: v for k, v in data.items() if k in cls_fields})

    def document_stat(  # noqa: PLR0913, PLR0917
        self,
        guild_id: int,
        stat: StatTypes,
        value: (float | (datetime.datetime | datetime.date)),
        timestamp: datetime.datetime,
        short_name: str,
        annual: bool,
        month: str | None = None,
        year: str | None = None,
        dry_run: bool = False,
        **kwargs: dict[str, any],
    ) -> StatDB:
        """Inserts a stat into the database.

        Args:
            guild_id (int): _description_
            stat (StatTypes): _description_
            value (float  |): _description_
            timestamp (datetime.datetime): _description_
            short_name (str): _description_
            annual (bool): _description_
            month (str | None, optional): _description_. Defaults to None.
            year (str | None, optional): _description_. Defaults to None.
            dry_run (bool, optional): _description_. Defaults to False.

        Returns:
            list: _description_
        """
        if type(value) is datetime.date:
            # convert date into something MongoDB wants to parse
            value = value.strftime("%Y-%m-%d")

        doc = {
            "type": "stat",
            "guild_id": guild_id,
            "stat": stat,
            "timestamp": timestamp,
            "month": month,
            "value": value,
            "short_name": short_name,
            "annual": annual,
            "year": year,
        }

        for key in kwargs:
            if key == "_id":
                # skip _id key
                continue
            if key not in doc:
                doc[key] = kwargs[key]

        _id = self.insert(doc)[0] if not dry_run else ObjectId()
        doc["_id"] = _id
        return self.make_data_class(doc)

    def document_award(  # noqa: PLR0913, PLR0917
        self,
        guild_id: int,
        user_id: int,
        award: AwardsTypes,
        eddies: int,
        value: float,
        short_name: str,
        annual: bool,
        month: str | None = None,
        year: str | None = None,
        dry_run: bool = False,
        **kwargs: dict[str, any],
    ) -> StatDB:
        """Insert an award into the DB.

        Args:
            guild_id (int): server ID
            user_id (int): user ID
            award (AwardsTypes): the enum type of the award won
            month (str): a readable format like 'Oct 22'
            eddies (int): the eddies won
            value (float): _description_
            short_name (str): _description_
            annual (bool): _description_
            month (str | None, optional): _description_. Defaults to None.
            year (str | None, optional): _description_. Defaults to None.
            dry_run (bool, optional): _description_. Defaults to False.

        Returns:
            list: _description_
        """
        doc = {
            "type": "award",
            "guild_id": guild_id,
            "user_id": user_id,
            "award": award,
            "timestamp": datetime.datetime.now(tz=pytz.utc),
            "month": month,
            "eddies": eddies,
            "value": value,
            "short_name": short_name,
            "annual": annual,
            "year": year,
        }

        for key in kwargs:
            if key not in doc:
                doc[key] = kwargs[key]

        _id = self.insert(doc)[0] if not dry_run else ObjectId()
        doc["_id"] = _id
        return self.make_data_class(doc)

    def find_entry(self, award_or_stat: StatDB) -> list[StatDB]:
        """Finds an award or stat in the database.

        Builds a query for the given award/stat and returns anything it finds.

        Args:
            award_or_stat (Stat): the award or stat to search

        Returns:
            list[STatDB]: the found entry(ies)
        """
        query = {
            "type": award_or_stat.type,
            "guild_id": award_or_stat.guild_id,
            "annual": award_or_stat.annual,
            "user_id": award_or_stat.user_id,
            "short_name": award_or_stat.short_name,
        }

        if not isinstance(award_or_stat.value, datetime.date):
            query["value"] = award_or_stat.value

        if award_or_stat.annual:
            query["year"] = award_or_stat.year
        else:
            query["month"] = award_or_stat.month

        match award_or_stat.type:
            case "award":
                query["award"] = award_or_stat.award
            case "stat":
                query["stat"] = award_or_stat.stat

        return self.query(query)

    def get_previous_stat(self, stat: StatDB) -> StatDB | None:
        """Searches the database for the previous stat of the same time.

        Args:
            stat (StatDB): the stat to get previous values for

        Returns:
            StatDB: the previous stat object
        """
        query = {"guild_id": stat.guild_id, "type": stat.type}

        if stat.annual:
            query["year"] = int(stat.year) - 1
        else:
            now = datetime.datetime.now(tz=pytz.utc)
            query["month"] = (stat.timestamp - datetime.timedelta(days=37 + now.day)).strftime("%b %y")

        match stat.type:
            case "award":
                query["award"] = stat.award
            case "stat":
                query["stat"] = stat.stat

        ret: list[StatDB] = self.query(query)
        return ret[0] if ret else None


class WordleAttempts(BaseClass):
    """Class for interacting with the 'awards' MongoDB collection in the 'bestsummereverpoints' DB."""

    def __init__(self) -> None:
        """Initialiation method."""
        super().__init__(collection="wordles")

    @staticmethod
    def make_data_class(data: dict[str, any]) -> WordleAttemptDB:
        """Converts the data into a WordleAttemptDB dataclass.

        Args:
            data (dict[str, any]): the data

        Returns:
            WordleAttemptDB: the data class
        """
        return WordleAttemptDB(**data)

    def document_wordle(self, guild_id: int, wordle_solve: WordleSolve) -> WordleAttemptDB:
        """Inserts a wordle entry into the database.

        Args:
            guild_id (int): the guild we created it in
            wordle_solve (WordleSolve): the wordle solve dataclass

        Returns:
            WordleAttemptDB: the created dataclass
        """
        doc = {k: v for k, v in wordle_solve.__dict__.items() if v is not None}

        doc["game_state"] = {str(k): v for k, v in doc["game_state"].items()}

        doc["guild_id"] = guild_id
        doc["timestamp"] = doc["timestamp"].strftime("%Y-%m-%d")

        _id = self.insert(doc)[0]
        doc["_id"] = _id
        return WordleAttemptDB(**doc)

    def find_wordles_at_timestamp(self, timestamp: datetime.datetime, guild_id: int) -> WordleAttemptDB | None:
        """Finds the wordle(s) for the given timestamp.

        Args:
            timestamp (datetime.datetime): the timestamp to search for
            guild_id (int): the guild ID the wordle attempt was posted in

        Returns:
            WordleAttemptDB: the found wordle or None.
        """
        results: list[WordleAttemptDB] = self.query({"timestamp": timestamp.strftime("%Y-%m-%d"), "guild_id": guild_id})
        if results:
            return results[0]
        return None


class BotActivities(BaseClass):
    """Class for interacting with the 'botactivities' MongoDB collection in the 'bestsummereverpoints' DB."""

    def __init__(self) -> None:
        """Constructor method that initialises the vault object."""
        super().__init__(collection="botactivities")

    @staticmethod
    def make_data_class(data: dict[str, any]) -> BotActivityDB:
        """Converts the data into a datatype.

        Args:
            data (dict[str, any]): the data to convert

        Returns:
            BotActivityDB: the dataclass
        """
        return BotActivityDB(**data)

    def insert_activity(self, category: str, name: str, created_by: int) -> BotActivityDB:
        """Inserts a new bot activity into the database.

        Args:
            category (str): the category - either: listening, watching, playing
            name (str): the activity name
            created_by (int): which user created it

        Returns:
            InsertOneResult: insert result
        """
        doc = {
            "category": category,
            "name": name,
            "created_by": created_by,
            "created": datetime.datetime.now(tz=pytz.utc),
            "count": 0,
            "archived": False,
        }

        _id = self.insert(doc)[0]
        doc["_id"] = _id
        return self.make_data_class(doc)

    def find_activity(self, name: str, activity: str) -> BotActivityDB:
        """Find an existing activity.

        Args:
            name (str): name fo the activity
            activity (str): the category

        Returns:
            dict: _description_
        """
        ret = self.query({"category": activity, "name": name})
        return ret[0] if ret else None

    def get_all_activities(self) -> list[BotActivityDB]:
        """Returns all activities from the collection.

        Returns:
            list: _description_
        """
        return self.query({"archived": False})


class WordleReminders(BaseClass):
    """Class for interacting with the 'wordlereminders' MongoDB collection in the 'bestsummereverpoints' DB."""

    def __init__(self) -> None:
        """Constructor method that initialises the vault object."""
        super().__init__(collection="wordlereminders")

    @staticmethod
    def make_data_class(data: dict[str, any]) -> WordleReminderDB:
        """Converts the data into a data class.

        Args:
            data (dict[str, any]): the data to convert

        Returns:
            WordleReminderDB: the dataclass
        """
        return WordleReminderDB(**data)

    def insert_reminder(self, name: str, created_by: int) -> WordleReminderDB:
        """Inserts a new wordle reminder into the database.

        Args:
            name (str): the reminder name
            created_by (int): which user created it

        Returns:
            InsertOneResult: insert result
        """
        doc = {
            "name": name,
            "created_by": created_by,
            "created": datetime.datetime.now(tz=pytz.utc),
            "archived": False,
        }

        _id = self.insert(doc)[0]
        doc["_id"] = _id
        return self.make_data_class(doc)

    def get_all_reminders(self) -> list[WordleReminderDB]:
        """Returns all reminders from the collection.

        Returns:
            list: _description_
        """
        return self.query({"archived": False})
