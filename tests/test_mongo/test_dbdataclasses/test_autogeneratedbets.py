"""Tests our AutoGeneratedBets class."""

from unittest import mock

import pytest

from mongo import interface
from mongo.bsedataclasses import AutoGeneratedBets
from mongo.datatypes.autogeneratedbets import AutoGeneratedBetDB
from tests.mocks import interface_mocks

BET_CACHE: list[dict[str, any]] | None = None


def _get_bet_data(number: int | None = None) -> list[dict[str, any]]:
    """Function for getting and caching internal data."""
    global BET_CACHE  # noqa: PLW0603
    if BET_CACHE is None:
        BET_CACHE = list(interface_mocks.query_mock("autogeneratedbets", {}))
    if not number:
        return BET_CACHE
    return BET_CACHE[-number:]


class TestAutoGeneratedBets:
    """Tests our AutoGeneratedBets class."""

    def test_auto_bets_init(self) -> None:
        """Tests AutoGeneratedBets init."""
        auto = AutoGeneratedBets()
        assert isinstance(auto, AutoGeneratedBets)

    def test_bets_make_data_class(self) -> None:
        """Tests AutoGeneratedBets make_data_class."""
        auto = AutoGeneratedBets()
        data = _get_bet_data()
        for entry in data:
            if "selectable" in entry:
                continue
            cls = auto.make_data_class(entry)
            assert isinstance(cls, AutoGeneratedBetDB)

    @pytest.mark.parametrize("bet_type", sorted({entry["type"] for entry in _get_bet_data()}))
    @mock.patch.object(interface, "get_collection", new=interface_mocks.get_collection_mock)
    @mock.patch.object(interface, "get_database", new=interface_mocks.get_database_mock)
    @mock.patch.object(interface, "insert", new=interface_mocks.insert_mock)
    def test_auto_bets_insert_generated_bet(self, bet_type: str) -> None:
        """Tests AutoGeneratedBets insert_generated_bet method."""
        auto = AutoGeneratedBets()
        bet = auto.insert_generated_bet(bet_type, "Some title", ["1", "2", "3", "4"])
        assert isinstance(bet, AutoGeneratedBetDB)
        assert bet.type == bet_type
        assert not bet.voice_channel

        bet = auto.insert_generated_bet(bet_type, "Some title", [])
        assert isinstance(bet, AutoGeneratedBetDB)
        assert bet.type == bet_type
        assert bet.voice_channel

    @mock.patch.object(interface, "get_collection", new=interface_mocks.get_collection_mock)
    @mock.patch.object(interface, "get_database", new=interface_mocks.get_database_mock)
    @mock.patch.object(interface, "insert", new=interface_mocks.insert_mock)
    def test_auto_bets_insert_category(self) -> None:
        """Tests AutoGeneratedBets insert_new_category method."""
        auto = AutoGeneratedBets()
        auto.insert_new_category("category")

    @mock.patch.object(interface, "get_collection", new=interface_mocks.get_collection_mock)
    @mock.patch.object(interface, "get_database", new=interface_mocks.get_database_mock)
    @mock.patch.object(interface, "query", new=interface_mocks.query_mock)
    def test_auto_bets_get_all_bets(self) -> None:
        """Tests AutoGeneratedBets get_all_bets method."""
        auto = AutoGeneratedBets()
        bets = auto.get_all_bets()
        assert isinstance(bets, list)
        for bet in bets:
            assert isinstance(bet, AutoGeneratedBetDB)

    @pytest.mark.parametrize("bet_type", sorted({entry["type"] for entry in _get_bet_data()}))
    @mock.patch.object(interface, "get_collection", new=interface_mocks.get_collection_mock)
    @mock.patch.object(interface, "get_database", new=interface_mocks.get_database_mock)
    @mock.patch.object(interface, "query", new=interface_mocks.query_mock)
    def test_auto_bets_get_bets_for_type(self, bet_type: str) -> None:
        """Tests AutoGeneratedBets get_bets_for_type method."""
        auto = AutoGeneratedBets()
        bets = auto.get_bets_for_type(bet_type)
        assert isinstance(bets, list)
        for bet in bets:
            assert isinstance(bet, AutoGeneratedBetDB)
            assert bet.type == bet_type

    @pytest.mark.parametrize("bet_type", sorted({entry["type"] for entry in _get_bet_data()}))
    @mock.patch.object(interface, "get_collection", new=interface_mocks.get_collection_mock)
    @mock.patch.object(interface, "get_database", new=interface_mocks.get_database_mock)
    @mock.patch.object(interface, "query", new=interface_mocks.query_mock)
    def test_auto_bets_get_random_bets_for_type(self, bet_type: str) -> None:
        """Tests AutoGeneratedBets get_random_bets_for_type method."""
        auto = AutoGeneratedBets()
        bets = auto.get_random_bets_for_type(bet_type)
        assert isinstance(bets, list)
        assert len(bets) <= 3
        for bet in bets:
            assert isinstance(bet, AutoGeneratedBetDB)
            assert bet.type == bet_type

    @mock.patch.object(interface, "get_collection", new=interface_mocks.get_collection_mock)
    @mock.patch.object(interface, "get_database", new=interface_mocks.get_database_mock)
    def test_auto_bets_get_bet_categories(self) -> None:
        """Tests AutoGeneratedBets get_bet_categories method."""

        class _Vault:
            """Mock vault for mocking 'distinct'."""

            @staticmethod
            def distinct(*_) -> list[str]:
                """Mock distinct function."""
                return ["a", "c"]

        auto = AutoGeneratedBets()
        with mock.patch("mongo.bsedataclasses.AutoGeneratedBets.vault", new=_Vault()):
            categories = auto.get_bet_categories()
        assert isinstance(categories, list)
